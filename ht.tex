\chapter{NVIDIA FleX und Unreal Engine 4 für Serious Games}
\label{chap_Flex_Engine}

In Kapitel \ref{chap_Flex_Engine} wird die verwendete Unreal Engine 4 mit FleX-integration evaluiert und wenn nötig verbessert. Die Evaluation dient dazu, einen Eindruck davon zu bekommen, wie gut die Software für die Entwicklung von Serious Games im medizinischen Bereich geeignet ist und ob noch fehlende Funktionalitäten hinzugefügt werden müssen. 

Wenn eine fehlende Funktionalität entdeckt wird, die für die Entwicklung von Serious Games unverzichtbar ist, wird direkt präsentiert, wie die fehlende Funktionalität implementiert wurde.

%nicht ändern, nur erweitern:
%Im Rahmen dieser Arbeit wird stets darauf geachtet, den Source Code der Unreal Integration nicht zu verändern. 
In dieser Arbeit wurden fehlende Funktionalitäten nur durch hinzufügen neuer Softwareelemente realisiert, nicht durch Veränderung der zugrundeliegenden Software. Dadurch können neue Versionen der Unreal Integration problemlos verwendet werden, durch einfaches Austauschen. 
%So soll die Qualitätsanforderung \textit{Modularität} eingehalten werden (siehe Kapitel \textbf{XXX}).


\section{Performance}
\label{sec_performance}

%\subsubsection{NVIDIA FleX}
NVIDIA FleX zeichnet sich laut diversen Quellen (\cite{FlexD3D}, \cite{UPP}, HIER NOCH MEHR REIN!) durch eine besonders gute Performance aus, wobei in \cite{FlexD3D} genauer darauf eingegangen wird, welchen Einfluss unterschiedliche Größen auf die Geschwindigkeit des Flex-Solvers haben. 

Laut \cite{FlexD3D} wirkt sich die Partikelanzahl weniger stark auf die Performance aus, wie die Anzahl und Komplexität der verwendeten Constraints oder die verwendeten Simulationsparameter. Befinden sich beispielsweise nur Soft Bodies in einer Szene, muss der Solver deutlich weniger unterschiedliche Constraints lösen, als in einer Szene, in der sich Soft Bodies, Flüssigkeiten und Stoffe befindet.

%Die Constraints \textbf{X, X und X} sind beispielsweise deutlich rechenaufwändiger, als ein einfaches \textbf{X-Constraint} (siehe \cite{FlexD3D}).% und wirken sich daher stärker auf die Rechenzeit aus.

Im Rahmen dieser Arbeit wurde die Performance von NVIDIA FleX in Verbindung mit Unreal Engine 4 ausführlich untersucht. In diesem Kapitel (\ref{sec_performance}) werden die Einflussgrößen präsentiert, die den größten Einfluss auf die Performance hatten.

\subsubsection{Verwendete Hardware}

Für diese Arbeit und für alle durchgeführten Messungen und Tests stand die Hardware aus Tabelle \ref{table_hardware} zur Verfügung.

%\clearpage

\begin{table}[hbt!]
\centering
\caption{Die verwendete Hardware.}
\label{table_hardware}
\begin{tabular}{l|l}
 \hline
CPU & Intel Core i7-9700K  \\ \hline
GPU & NVIDIA GTX 1070 - 8GB GDDR5      \\ \hline
RAM & 32GB DDR4            \\ \hline
\end{tabular}
\end{table}

%Die verwendete Grafikkarte gehört zur vorletzten Generation der NVIDIA Grafikkarten und ist somit weniger aktuell und nicht übermäßig stark.

%% Please add the following required packages to your document preamble:
%% \usepackage{booktabs}
%\begin{table}[]
%\centering
%\caption{Einige Boid-Erhaltungsmessungen. Der Verlust von Boids konnte eindeutig nachgewiesen werden. Vor allem bei der Verteilung in zwei Zellen traten massive Verluste auf. }
%\label{Erhaltungsmessungen}
%\begin{tabular}{@{}llll@{}}
%\toprule
%\begin{tabular}[c]{@{}l@{}}Anzahl der\\ Wahrnehmungsvektoren\end{tabular} & Transportmethode                                                               & \begin{tabular}[c]{@{}l@{}}absoluter \\ Verlust\end{tabular} & \begin{tabular}[c]{@{}l@{}}prozentualer\\ Verlust\end{tabular} \\ \midrule

\subsection{Performance Tests}
\label{subsec_perf_tests}
\subsubsection{Gemischte Simulationen}

Um einen ersten Überblick von der Performance zu bekommen, wird zunächst eine Szene simuliert, in der sich mehrere unterschiedliche Objektarten befinden. Dadurch wird des FleX-Solver stark belastet, weil er viele unterschiedliche Constraints lösen muss. Dazu gehören beispielsweise Shape Constraints (Soft- und Rigid Bodies), Spring-Constraints (Stoff-Objekte), Flüssigkeiten (Density Constraints), sowie Kollisions Constraints und Friction Constraints.

%\bild{WaterInteraction}{10cm}{Mehrere Objektarten interagieren auf realistische Weise miteinander. Werkzeuge (Skalpelle) werden von der Flüssigkeit weggespült und Körper, die eine geringere Dichte als die Flüssigkeit haben, schwimmen.}

\bild{WaterShaderPerformance}{14cm}{Mehrere Objektarten interagieren auf realistische Weise miteinander. Wird ein aufwändiger Shader für die Fluid-Partikel verwendet, kommt die GPU schnell an ihre Grenzen und die \ac{FPS} werden deutlich verringert.}

Die Simulationsparameter werden außerdem so gewählt, dass die Simulation möglichst akkurat ausgeführt wird, wodurch der FleX-Solver ebenfalls stärker belastet wird. Die gewählten Simulationsparameter wurden so wie in \cite{BreastBiopsy} gewählt. Diese Parametrisierung hat sich nämlich auch in \cite{PBDKidney} und \cite{VRSim20} bewährt um Gewebe akkurat zu simulieren.

Die verwendeten Simulationsparameter. sowie alle Messergebnisse sind in Tabelle \ref{table_mixed_sim} zu sehen.

\begin{table}[hbt!]
\centering
\caption{Simulationsparameter und Messergebnisse der simulierten Szene.}
\label{table_mixed_sim}
\begin{tabular}{l|l}
 \hline
Partikelradius & 1 cm  \\ \hline
Simulation Substeps & 3      \\ \hline
Substep Iterations & 9            \\ \hline
Anzahl Partikel & 32021            \\ \hline
Davon Fluid Partikel & 16384	\\ \hline
Anzahl Shape-Constraints & 1214		\\ \hline
Anzahl Federn & 15360 		\\ \hline
Self Collision & aktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
\textbf{Solve Sync Time (CPU)} & \textbf{0,35 ms}
\end{tabular}
\end{table}

Der Wert \textit{Solve Sync Time} gibt an, wie lange die CPU gewartet hat, bis die FleX Simulation für einen Frame von der GPU abgearbeitet wurde. Das heißt dass der FleX Solver wahrscheinlich noch schneller gearbeitet hat, als angegeben, weil die Datentransferzeiten zwischen CPU und GPU in den Messungen enthalten sind. Dennoch ist dies ein gutes Maß dafür, wie schnell die FleX Simulation ist.

Das Ergebnis von 0,35 ms ist zufriedenstellend. Die GPU hat dadurch noch genügend Zeit um die Szene mit 60-120 \ac{FPS} bei 1080p zu rendern, solange einfache Rendertechniken und mittelmäßig komplexe Shader eingesetzt werden. 

Was in dieser Arbeit besonders auffiel, ist dass das Rendern von simulierten Flüssigkeiten besonders rechenintensiv werden kann. Wird die Flüssigkeit mit aufwändigen Wasser Shadern gerendert, so wie in Abbildung \ref{WaterShaderPerformance} rechts, Kann dies zu deutlich weniger \ac{FPS} führen. Es ist also ratsam, besonders effiziente Rendertechniken für simulierte Flüssigkeiten einzusetzen.

Weil für chirurgische Simulatoren vor allem das Simulieren von Weichkörpern interessant ist, werden die nächsten Tests nurnoch mit Soft Bodies simuliert, die aus clustered Shape-Constraints bestehen.

%\begin{table}[]
%\centering
%\caption{Neue Objektarten wurden Schrittweise hinzugefügt}
%\label{table_mixed_res}
%\begin{tabular}{l|rrrr|l}
%\textbf{Hinzugefügt} & \multicolumn{1}{l}{\textbf{Partikelanzahl}} & \multicolumn{1}{l}{\textbf{Shape Constraints}} & \multicolumn{1}{l}{\textbf{Fluid Partikel}} & \multicolumn{1}{l|}{\textbf{Distance Constraints}} & \textbf{Solve Sync Time} \\ \hline
%Nur Soft Bodies      & 12548                                       & 1209                                           & 0                                           & 0                                                  & 0.16                     \\
%+ Flüssigkeit        & 28932                                       & 1209                                           & 16384                                       & 0                                                  & 0.17                     \\
%+ Stoff              & 31494                                       & 1209                                           & 16384                                       & 15360                                              & 0.31                     \\
%+ Rigid Bodies       & 32021                                       & 1214                                           & 16381                                       & 15360                                              & 0.35                    
%\end{tabular}
%\end{table}
\clearpage
\subsubsection{Simulationsparametrisierung}

Für alle Messungen, die in diesem Kapitel präsentiert werden, wurden die Einstellungen aus Tabelle \ref{table_soft_param} verwendet.

\begin{table}[hbt!]
\centering
\caption{Verwendete Parameter für diesen Versuch}
\label{table_soft_param}
\begin{tabular}{l|l}
 \hline
Partikelradius & 1 cm  \\ \hline
Simulation Substeps & variierend (2-3)      \\ \hline
Substep Iterations & variierend (3-9)            \\ \hline
Simulierte Objektarten &  nur Soft Bodies mit Shape Constraints\\ \hline
Self Collision & deaktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
\end{tabular}
\end{table}

%TODO: Auf Substeps und Substep iterations eingehen!!!

In Abbildung \ref{figure3} ist zu sehen, wie schnell unterschiedlich viele Soft Bodies simuliert werden konnten, bei unterschiedlichen Simulationsparametern. %Für alle Simulationen wurde ein Partikelradius von 1 cm verwendet. 
Mit den Simulationsparametern von der blauen Kurve können bereits erste optisch realistisch wirkende Simulationen ausgeführt werden, wobei sich damit keine akkuraten Gewebeverformungen simulieren lassen. Wie man sieht, steigt die Blaue Kurve nur sehr schwach an (Steigung ca. $10^{-5}$). Selbst wenn über 100 Tausend Partikel (26 Soft Bodies, 10478 Cluster) simuliert werden, benötigt der FleX-Solver nur 1,12 Millisekunden für einen Simulationsschritt. Die Szene konnte daher immer mit 120 FPS gerendert werden.
\clearpage
\bild{figure3}{11cm}{Die blaue Kurve zeigt die Simulationsgeschwindigkeit von FleX bei einfachen (kleinen) Simulationsparametern. Die rote Kurve zeigt die die Simulationsgeschwindigkeit von FleX bei einer akkurateren Simulation mit größeren Simulationsparametern.}

Wird die Simulation allerdings akkurater ausgeführt, mit den Parametern der roten Kurve (gut für akkurate Gewebesimulationen), wird die Lösungsgeschwindigkeit ab einer kritischen Partikelanzahl deutlich langsamer. Im Diagramm \ref{figure3} erkennt man sehr deutlich, wie die rote Kurve ab einer Partikalanzahl von etwa 60 Tausend nach oben schießt. Davor läuft die Simulation nahezu genauso schnell wie zuvor, bei geringeren Simulationsparametern.
%, mit einer Steigung von ca. 0,28.
Abbildung \ref{figure4} zeigt welche Auswirkung die steigende Simulationszeiten auf die Renderfrequenz hatten. Hierzu sei gesagt, dass in dieser Szene mittelmäßig komplexe Shader und Grafikeinstellungen eingesetzt wurden.

\bild{figure4}{12cm}{...}

Das plötzliche Ansteigen der Simulationszeiten bei der akkurateren Simulation weist auf eine Hardwaregrenze hin, bei der nicht mehr genügend Hardwareressourcen zur Verfügung stehen um weiterhin effizient arbeiten zu können. Der Grafikspeicher der Grafikkarte wurde allerdings niemals voll ausgenutzt (maximal 4 von 8 GB wurden belegt). Die Grenze von 60 Tausend Partikeln konnte im Anwendungsteil dieser Arbeit nie überschritten werden. Im finalen chirurgischen Simulator mussten lediglich 12000 Partikel simuliert werden (siehe Kapitel XXX). Dadurch konnten problemlos zusätzliche Simulationen ausgeführt und komplexere Rendertechniken eingesetzt werden, ohne negativen Einfluss auf die FPS.



% ------ HIER EVT FIGURE 6 präsentieren, sprengt aber evt den Rahmen!!! -----------------------

%Als nächstes wurde eine Szene mit konstanter Partikelanzahl simuliert, während einzelne Simulationsparameter stufenweise angehoben wurden.
%figure6

\clearpage
\subsubsection{Cluster Konfigurationen}


%Zeige: Viele kleine Cluster vs wenig große Cluster -> Viele kleine Cluster ist deutlich performanter als wenige große Cluster. WIESO? -> FleX löst Constraints parallelisiert. Die Lösung eines einzelnen Constraints ist eine sequenzielle Operation. Je größer ein Cluster, desto mehr Partikel beinhaltet. Je mehr Partikel in einem Cluster, desto rechenintensiver ist die Lösung des Shape Constraints!

%In diesem Kapitel wird untersucht welchen Einfluss unterschiedliche Cluster Konfigurationen auf die Simulationsperformance von Soft Bodies, die aus Shape-Constraints bestehen, haben. 

In diesem Kapitel wird untersucht welchen Einfluss unterschiedliche Cluster Konfigurationen auf die Performance von Shape-Constraint-basierten Soft Body Simulationen haben. 

Hierfür wurden zwei sehr ähnliche FleX Assets modelliert, die sich nur durch ihre Cluster Konfigurationen unterscheiden (siehe Tabelle \ref{table_clusters}). Der wesentliche Unterschied zwischen den beiden Assets ist, dass Asset A aus vielen kleinen Clustern besteht, während Asset B aus wenigen großen Clustern besteht, so wie in Abbildung \ref{Clusters} zu erkennen. 

\bild{Clusters}{14cm}{Das selbe FleX-Asset mit zwei unterschiedlicher Cluster Anordnungen. Die Cluster werden als Koordinatensysteme visualisiert. Das linke Asset hat viele kleine Cluster, während das Rechte wenige große Cluster besitzt. Mit beiden Assets können optisch realistisch wirkende Deformationen simuliert werden, allerdings gibt es große Performance Unterschiede.}

Eine erste intuititive Vermutung wäre nun, dass Asset B performanter simuliert werden kann, weil hier weniger Shape-Constraints gelöst werden müssen. Aus den Messergebnissen (siehe Tabelle \ref{table_clusters}) geht allerdings das Gegenteil hervor: Bei Asset B wurde eine 70 mal größere Solve Sync Time gemessen als bei Asset A. 
%Dadurch konnte Asset B nurnoch mit 46 FPS gerendert werden, während Asset A bei 120 FPS gemessen wurden.

%\begin{table}[]
%\centering
%\caption{Verwendete Parameter für diesen Versuch}
%\label{table_soft_assets}
%\begin{tabular}{l|l}
% \hline
%Partikelradius & 1 cm  \\ \hline
%Simulation Substeps & 3     \\ \hline
%Substep Iterations & 9            \\ \hline
%Simulierte Objektarten &  nur Soft Bodies mit Shape Constraints\\ \hline
%Self Collision & deaktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
%\end{tabular}
%\end{table}

\begin{table}[hbt!]
\centering
\caption{Messergebnisse des Cluster Versuchs. Assets mit mehr und dafür kleineren Clustern performen deutlich besser.}
\label{table_clusters}
\begin{tabular}{lcc}
                                         & \textbf{Asset A}      & \textbf{Asset B}      \\ \hline
\multicolumn{1}{l|}{Partikelradius}      & 1                     & 1                     \\
\multicolumn{1}{l|}{Simulation Substeps} & 3                     & 3                     \\
\multicolumn{1}{l|}{Substep Iterations}  & 9 					 & 9 				     \\
\multicolumn{1}{l|}{Partikelanzahl}      & 23815                 & 23815                 \\
\multicolumn{1}{l|}{Clusterradius}       & 6                     & 20                    \\
\multicolumn{1}{l|}{Clusteranzahl}       & 133                   & 18                    \\
\multicolumn{1}{l|}{Partikel / Cluster}  & 179                   & 1323                  \\ \hline
\multicolumn{1}{l|}{Solve Sync Time}     & 0,24 ms               & 16,83 ms              \\
\multicolumn{1}{l|}{FPS}                 & 120                   & 46   
\end{tabular}
\end{table}

%Aus diesen Messergebnissen lässt sich eine wichtiger Grundsatz ableiten: Je mehr Shape Constraints ein 

Die GPU kommt also offenbar bei der Verarbeitung von wenigen großen Clustern schnell an ihre Grenzen.
%Das hat damit zu tun, wie NVIDIA FleX die Partikel und Constraints verarbeitet. 

Hierfür gibt es zwei Ursachen: Zum Einen ist die Verarbeitung der Shape Constraints laut \cite{FlexD3D} aufwändig, weil hierbei die Momentenmatrizen der Cluster polar zerlegt werden müssen. Das ist besonders rechenintensiv.

Zum Anderen verarbeitet NVIDIA FleX Shape Constraints nach der sogenannten Constraint otientierten Methode. Um die Simulation zu verarbeiten, wird in \cite{UPP} zwischen zwei unterschiedlichen Verarbeitungsansätzen unterschieden: Partikel orientiert und Constraint orientiert. 

Beim Partikel orientierten Ansatz werden alle Partikel parallel verarbeitet und für jedes Partikel werden die Constraints, die das Partikel beeinflussen, sequenziell verarbeitet. 

Beim Constraint orientierten Ansatz werden alle Constraints parallel verarbeitet und alle Partikel, die ein Constraint beeinflusst, werden sequenziell verarbeitet, beziehungsweise verschoben. 

NVIDIA FleX setzt beide Verarbeitungsansätze ein, je nachdem um welche Art von Constraint es sich handelt. Shape-Constraints werden mit dem Constraint orientierten Ansatz verarbeitet \cite{FlexD3D}. Weil für jedes Cluster ein entsprechendes Shape-Constraint gelöst wird, kann man sich also vorstellen, dass alle Cluster parallel verarbeitet werden, während alle Partikel, die sich innerhalb eines Clusters befinden, sequenziell verarbeitet werden. Je größer ein Cluster, desto mehr Partikel beinhält es und desto mehr Partikel müssen sequenziell verarbeitet werden. 

Deswegen ist es besser viele kleine Cluster zu verwenden. So wird mehr Arbeit parallelisiert (viele Cluster) und es muss weniger sequenziell verarbeitet werden (wenig Partikel pro Cluster). Außerdem bringt dies den zusätzlichen Vorteil mit sich, dass sich ein Soft Body, das aus vielen Clustern besteht, vielfältiger verformen lässt.



\subsubsection{Self Collision und Partikelradius}

%Fazit: Wenig Partikelüberschneidung bei Self Collision. Wichtig zu erwähnen: Führt auch zu instabilen, zitternden Zuständen! Außerdem: Je mehr Kollisionen/Kontackte existieren, desto mehr Collisions und friction constraints müssen gelöst werden.

In diesem Kapitel wird untersucht wie stark sich unterschiedliche Partikelradi auf die Simulationsperformance von Soft Bodies auswirkt. Hierfür wurde eine Szene mit den Einstellungen aus Tabelle \ref{table_self_collision} simuliert. 

\begin{table}[hbt!]
\centering
\caption{Verwendete Parameter für diesen Versuch}
\label{table_self_collision}
\begin{tabular}{l|l}
 \hline
Partikelradius & variierend  \\ \hline
Simulation Substeps & 3      \\ \hline
Substep Iterations & 9            \\ \hline
Simulierte Objekte &  10 Soft Bodies \\ \hline
Self Collision & variierend \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
Ignore Rest Collision & True\\ \hline
Shape-Constraints & 850            \\ \hline
Partikelanzahl & 26010            \\ \hline
\end{tabular}
\end{table}

Dabei wurde der Partikelradius stufenweise erhöht. 

\bild{RadiusOctupus}{14cm}{Je größer der Partikelradius, desto mehr Selbstkollisionen kommen in einem einzelnen Asset vor. Sind die Partikel zu klein, entstehen Lücken zwischen den Partikeln (links). Das sollte vermieden werden, sonst können Objekte durch solche Lücken hindurch fallen.}

Dieser Test wurde einmal mit Assets durchgeführt, bei denen \textit{Self Collision} aktiviert war und einmal mit Assets, bei denen \textit{Self Collision} deaktiviert war. Ist \textit{Self Collision} aktiviert, können die Partikel, die sich innerhalb eines Assets befinden, miteinander kollidieren, wobei bei der Ruhestellung keine Kollisionen stattfinden (Parameter \textit{IgnoreRestCollisions=True}). Ist Self Collision deaktiviert, können die Partikel des selben FleX Objekts nicht miteinander kollidieren. Nur mit den Partikeln von anderen Objektinstanzen.

Die Messergebnisse sind in Abbildung \ref{figure5} zu sehen.

\bild{figure5}{10cm}{...}

Wie man sieht entsteht ab einem Partikelradius von etwas 15 cm ein starker Performance Verlust, allerdings nur wenn Self Collision aktiviert ist. Das liegt vermutlich daran, dass sich mit wachsendem Partikelradius benachbarte Partikel immer stärker überlappen (siehe Abbildung \ref{RadiusOctupus}). Dabei entstehen immer mehr Partikelkollisionen. Ab einem bestimmten Punkt stehen nicht mehr genügend Hardwareressourcen zur Verfügung um die vielen Kollisions-Constraints zu lösen.

Solange sich die Partikel nicht zu stark überlappen (so wie in Abbildung \ref{RadiusOctupus}, Mitte), kommt FleX allerdings gut mit der Kollisionsverarbeitung zurecht, selbst wenn Self Collision aktiviert ist.

\subsection{Zusammengefasste Erkenntnisse}
\label{subsec_perf_zusa}

Mithilfe der durchgeführten Tests konnten wichtige Erkenntnisse über die Performance von FleX Simulationen gewonnen werden. Zusammengefasst sind dies die wichtigsten Punkte, auf die zu achten ist, um effiziente FleX Simulationen zu erhalten:

    \begin{itemize}
    
      \item \textbf{Hardwaregrenzen:} \\Die Performance von FleX Simulationen skaliert nur flach mit der Partikel- und Constraint-Anzahl, solange alle Cluster klein sind. Je nach Hardware gibt es jedoch eine Grenze, bei der die Performance deutlich stärker mit wachsender Partikel- und Constraint Anzahl abfällt. Je nach Simulationsparametrisierung tritt diese Grenze früher oder später auf. Die Hardwaregrenze sollte bekannt sein und nicht überschritten werden um noch genügend Ressourcen für zusätzliche Simulationen und fotorealistisches Rendern zu haben.
      
      \item \textbf{Partikeldichte:} \\ Bei der Modellierung von FleX Assets sollten sich benachbarte Partikel berühren, aber nicht zu stark überlappen. Vor allem wenn Self Collision aktiviert ist, können zu viele Kollisions-Constraints entstehen, was die Performance negativ beeinflusst.
      
      \item \textbf{Geringe Partikelanzahl pro Cluster:} \\ Bei der Modellierung von Soft Assets sollten viele kleine Cluster verwendet werden. Das heißt, die Cluster sollten nur wenige Partikel, etwa 200, umfassen. Je mehr Partikel die Cluster verarbeiten müssen, desto schneller kommt die Hardware an ihre Grenzen.
      
      \item \textbf{Simulationsparametrisierung:} \\ In einigen Arbeiten und auch in dieser Arbeit, erwiesen sich die Simulationsparameter aus Tabelle \ref{table_perf_zusa} als geeignet um performante und akkurate Simulationen zu erhalten:.
      
    \end{itemize}

\begin{table}[hbt!]
\centering
\caption{Empfohlene Simulationseinstellungen}
\label{table_perf_zusa}
\begin{tabular}{l|l}
 \hline
Partikelradius & \begin{tabular}[c]{@{}l@{}}So dass die Form der simulierten Körper\\ gut von Partikeln repräsentiert werden kann.\end{tabular}  \\ \hline
Simulation Substeps & 3      \\ \hline
Substep Iterations & 9            \\ \hline
%Self Collision & Je nach Bedarf. \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
%Ignore Rest Collision & True\\ \hline
%Maximale Partikelanzahl & Je nach Hardware bis zu über 100.000 möglich\\ \hline
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%% ALT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Test Szenario}

%Für die Anwendungsfälle dieser Arbeit sind vor allem Soft Bodies interessant. Daher wird nun eine Szene simuliert, in der sich ausschließlich Soft Bodies befinden (siehe Abbildung \ref{PerfGTX1Scene}). 
%
%TODO: Welche Constraints verwendet und wie viele???!!!
%
%\bild{PerfGTX1Scene}{12cm}{In der Testszene befinden sich mehrere unterschiedliche Soft Bodies, die eine Treppe hinunter rollen.}
%
%Die simulierten Körper kollidierten und verformten sich dabei stets augenscheinlich realistisch.
%
%Folgenden Simulationsparameter wurden eingesetzt (siehe Abbildung \ref{PerfGTX1Set}):
%
%\bild{PerfGTX1Set}{10cm}{Die verwendeten Simulationsparamer für dies Testreihe.}
%
%Für alle Messungen wurde der Simulationsparameter \textit{Sleep Threshold} auf einen negativen Wert gesetzt, um zu verhindern, dass zu langsame Partikel von der Simulation ausgeschlossen werden.

%Alle Messungen wurden mithilfe des Befehls \textit{stat flex} ermittelt. In \cite{UE4FlexDoc} unter \url{gameworksdocs.nvidia.com/FleX/1.2/ue4_docs/FLEXUe4_Debug.html} kann nachgeschlagen werden, was die gemessenen und gezeigten Attribute bedeuten.

%\subsubsection{Messergebnisse}
%
%%Typische Frametime: 15 ms bis 17ms sind im 60 fps-Bereich (1000ms / 15 ms = 66,66… FPS)
%
%In Abbildung \ref{PerfGTX1} sind die Messdaten zu sehen, die sich ergaben.
%
%\bild{PerfGTX1}{14cm}{TEMP!!! Performance Messungen bei unterschiedlichen Partikelanzahlen mit einem Partikelradius von 10cm. Die durchschnittliche Solver Zeit steigt flach und linear mit der Partikelanzahl an.}
%
%Zu den Messdaten sei gesagt, dass \textit{Solve Sync Time} mithilfe der CPU gemessen wurde. \textit{Solve Sync Time} repräsentiert also nicht nur die Zeit, die der Flex-Solver benötigt, sondern zusätzlich die CPU-GPU Synchronisierungszeit. Dennoch ist dies ein gutes Maß für die Performance von NVIDIA Flex. 
%
%Zur gemessenen Performance: 
%Die Messungen zeigen eindeutig, dass NVIDIA Flex besonders gut für Echtzeitanwendungen geeignet ist. Selbst bei 70000 simulierten Partikeln (und 134 Soft Bodies) benötigt der Flex Solver durchschnittlich nur 1 ms zum Lösen aller Constraints, wobei er maximal 2,5 ms benötigt, was immer noch im akzeptablen Bereich für eine realistische Optik liegt. 
%
%%In Abbildung \ref{PerfGTX1} zeigt die Linie \textit{SumAvg} an, wie lange der gesamte Simulationsprozess im Durchschnitt gedauert hat. Der gesamte Simulationsprozess ergibt sich aus den Zeiten der folgenden Arbeitsschritte, summiert (Abbildung \ref{PerfStats}):
%
%%\bild{PerfStats}{12cm}{Alle gemessenen Arbeitsschritte und ihre Bedeutungen \cite{UE4FlexDoc} -> Das hier evt nur als Anlage???}
%
%Dank der beeindruckenden Geschwindigkeit des Flex-Solvers konnten alle Tests mit 120 \ac{FPS} gerendert werden, bei einer Auflösung von ca. 1080p. 
%%Mit einer Oculus Quest 2 konnte die Szene stets mit 90 FPS bei einer Auflösung von \textbf{XXX} dargestellt werden. 
%So wie in \cite{FlexD3D} bereits erwähnt, 
%%hat die Anzahl der simulierten Partikel einen geringen Einfluss auf die Geschwindigkeit des Solvers.
%skaliert die Simulationsgeschwindigkeit nur schwach mit der Partikelanzahl.



%Auch wenn die Messungen viel versprechen, wird sich erst am Ende dieser Arbeit zeigen (siehe Kapitel \ref{chap_Szenarien}), ob NVIDIA Flex für Serious Games im chirurgischen Bereich geeignet ist.

%% ----EVT TODO--------
%Dann nochmal mit kleineren Partikeln und mehr substeps simulieren, weil das besser auf chirurges-szenario passt. In einigen anderen Arbeiten wurden ja auch recht kleine radi verwendet und mehr substeps usw (könnte man auch kurz drauf verweisen, auf diese paper und argumentieren das wir daher besser auf solche szenarien achten sollten)

%%%%%%%%%%%%%%%% ALT ENDE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\section{Funktionalitäten}
In der Einleitung von \cite{UE4FlexDoc} wird bereits darauf hingewiesen, dass die Unreal Integration noch nicht weit genug entwickelt ist, um Gameplay-beeinflussende Physikszenarios zu erstellen. In diesem Kapitel wird genauer untersucht, welche   Funktionalitäten  die Unreal Integration bereits bietet und welche noch fehlen. 
%Hierfür gehen wir nach und nach alle funktionalen Anforderungen aus Kapitel \textbf{XXX} durch und kontrollieren, ob Anforderungen fehlen oder nur teilweise vorhanden sind.

%\subsection{Synchronisation mit Flex Simulation}

%... kommt evt raus, ist ja nicht so wichtig....

\subsection{Transformationsmanipulationen}


Game Engines verfügen in der Regel über eine umfangreiche Bibliothek für Transformationsberechnungen. So können Punkte oder Richtungen mit homogenen Transformationen manipuliert und die Transformationsmatrizen von unterschiedlichen 3D-Objekten miteinander verrechnet werden.
Dies ist eine wichtige Grundlage um 3D-Objekte bewegen, rotieren und skalieren zu können. 

Die Unreal Engine bietet hierfür den Datentyp \textit{FTransform} und die Bibliothek \textit{TransformCalculus.h} an. Jedes 3D-Objekt besitzt eine eigene Transformation, die zur Laufzeit manipuliert werden kann. Häufig werden die beiden Funktionen \textit{SetWorldTransform($T_{world}$)} und \textit{SetRelativeTransform($T_{relative}$)} genutzt um 3D-Objekte relativ zur Welt oder relativ zum derzeitigen Parent-Objekt zu bewegen.

Bei der Unreal Engine mit Flex Integration wurde das Transformations-Framework nur teilweise für Flex-Objekte angepasst. Obwohl alle FlexComponents eine eigene Transformation vom Typ FTransform besitzen, kann diese weder relativ noch absolut gesetzt werden. Die beiden Funktionen \textit{SetWorldTransform()} und \textit{SetRelativeTransform()} haben keine Auswirkung auf FlexComponents.

Diese wichtige Funktionalität muss also noch hinzugefügt werden. Dabei wird das bereits bestehende Transformations-Framework der Unreal Engine benutzt.

\subsubsection{\textit{SetWorldTransform}}

Um die Welt-Transformation eines Flex-Objekts zu ändern, müssen die Positionen all seiner Partikel mithilfe einer homogenen Transformationsmatrix, $T_{world}$, transformiert werden. Über die NVIDIA FleX Bibliothek können die lokalen Positionen, $\vec{p}_{local}$, der Partikel eines Flex-Assets 
%(\textit{float* NvFlexExtInstance::NvFlexExtAsset::particles}) % das hier evt weg machen!!!!
ermittelt werden. Das sind die lokalen Partikelpositionen des Flex-Assets, in seiner Ruheposition. Die neue Position, $\vec{p}_{new}$ eines Partikels ergibt sich dann mit Gleichung \ref{form_worldtransf}.

\begin{equation}
\vec{p}_{new} = T_{world} \cdot \vec{p}_{local}
\label{form_worldtransf}
\end{equation}

Gleichung \ref{form_worldtransf} ist im Grunde nichts anderes als die Transformation eines Punktes vom Objekt-Koordinatensystem ins Weltkoordinatensystem. Im Rahmen dieser Arbeit hat es sich als hilfreich erwiesen, die Geschwindigkeiten der transformierten Partikel auf null zu setzen, um das versetzte Flex-Objekt sofort in einen ruhigen Simulationszustand zu versetzten. 

Soll ein Flex-Objekt  über einen längeren Zeitraum entlang einer Trajektorie bewegt werden, ist es sinnvoll, die bewegten Partikel von der Flex-Simulation auszuschließen, indem ihre invertierten Massen auf null gesetzt werden. Dadurch sind die bewegten Partikel unendlich schwer und können nicht mehr von der Flex-Simulation bewegt werden \cite{PBD} \cite{UPP}. 

Weil bewegte Partikel von der Simulation ausgeschlossen werden, erscheinen bewegte Weichkörper starr. Um bewegte Weichkörper weiterhin elastisch erscheinen zu lassen, wird nur eine Teilmenge der Partikel bewegt. Dann erscheint nur ein Teil des bewegten Körpers starr und der Rest bleibt elastisch und folgt den bewegten Partikeln.

\subsubsection{\textit{SetRelativeTransform}}
\label{subsubsec_reltrans}
%Um ein Partikel relativ zu einer Parent-Szene zu bewegen (\textit{SetRelativeTransform()}), wird zunächst die allgemeine Situation aus Abbildung \ref{Transform1} betrachtet:

% eventuel streichen!
%\bild{Transform1}{10cm}{Um ein Partikel mit $T_{rel}$ relativ zu \textit{ParentScene} zu transformieren, muss das Matrixprodukt aus der Welt-Transformation von \textit{ParentScene}, $T_{parent}$, und $T_{rel}$ gebildet werden.}

Gegeben sei die Welt-Transformation einer Parent-Szene, $T_{parent}$ und die gewünschte Transformation, $T_{rel}$, die das Partikel relativ zur Parent-Szene einnehmen soll 
%(siehe Abbildung \ref{Transform1}). 
Dann kann mit Gleichung \ref{form_reltransf} die neue Weltposition, $\vec{p}_{new}$, des Partikels berechnet werden.

\begin{equation}
\vec{p}_{new} = T_{parent} \cdot T_{rel} \cdot \vec{p}_{local}
\label{form_reltransf}
\end{equation}

Gleichung \ref{form_worldtransf} und \ref{form_reltransf} sind einfache homogene Matrix-Vektor-Multiplikationen und sollten daher effizient von heutiger Hardware gelöst werden können. Außerdem kann die Berechnung der Partikelpositionen parallelisiert werden.

\subsection{Befestigung von FleX Objekten}
\label{subsec_attach}

%Für gewöhnlich arbeiten Game Engines mit sogenannten Scene Trees um 3D-Objekte hierarchisch zu organisieren (REFERENZ). Dabei repräsentiert jedes 3D-Objekt einen Knoten im Scene Tree. 3D-Objekte werden aneinander befestigt, so das sich eine Baumstruktur bildet, in der die Kinderobjekte an ihre Elternobjekte befestigt sind. Ändert sich die Transformation eines Elternknotens, bewegen sich all seine Kinderobjekte mit. 
%
%\bild{SceneTree}{8cm}{Alle Szenen und 3D-Objekte werden in einem Szene Tree organisiert}
%
%Die Struktur eines Scene Trees lässt sich zur Laufzeit eines Spiels ändern, indem 3D-Objekte per Funktionsaufruf von ihren Eltern gelöst (\textit{Detach()}) oder an andere 3D-Objekte befestigt (\textit{AttachTo(NewParent)}) werden. Diese beiden Funktionen werden in Computerspielen häufig benötigt, beispielsweise damit der Spieler 3D-Objekte aufheben (\textit{AttachTo(Hand)}) und wieder loslassen (\textit{Detach()}) kann.

\subsubsection{Befestigung von Flex-Partikeln an Szenen}

In der Unreal Integration können mehrere Flex-Partikel an eine Szene befestigt werden. Hierfür stehen allerdings nur Funktionen zur Verfügung, bei denen alle Partikel, die sich innerhalb einer Kugel befinden, befestigt werden. Auf Grundlage dieser Funktion wurden daher weitere Funktionen angelegt, um einzelne Partikel via Partikelindex an SceneComponents befestigen zu können.

Um ein Flex-Partikel an eine Szene zu befestigen, muss dessen inverse Masse, $w$, auf 0 gesetzt werden. Dann hat das Partikel eine unendlich große Masse und kann nicht mehr von der FleX Simulation bewegt werden. 
Gegeben sei außerdem die Position, $\vec{p}_{local}$, die das Partikel relativ zur Szene beibehalten soll. Immer wenn sich die Szene bewegt, wird die Weltposition, $\vec{p}_{new}$, des befestigten Partikels so verändert, dass die relative Position $\vec{p}_{local}$ unverändert bleibt.
$\vec{p}_{new}$ kann mithilfe von Gleichung \ref{form_reltransf} aus Kapitel \ref{subsubsec_reltrans} berechnet werden.

%Des weiteren musste eine Funktion zum Lösen von befestigten Partikel angelegt werden (\textit{DetachAllFlexParticles()}), weil auch solch eine Funktionalität fehlte.


%%% EVT noch genauer beschreiben wie genau das Befestigen funktioniert...

\subsubsection{Befestigung von Szenen an Szenen}

Erfreulicherweise unterstützt die verwendete Unreal Integration bereits das Befestigen von Szenen oder anderen 3D Objekten an ein Flex-Objekt. Allerdings drehen sich Szenen nicht mit Soft Bodies mit. Nur die Position der befestigten Szenen wird angepasst, während die Rotation unverändert bleibt. 

%Diese Problemstellung wurde im Rahmen dieser Arbeit nicht weiter verfolgt, weil hier keine Szenen an Soft Bodies befestigt werden mussten. Es wurden nur Szenen an Rigid Bodies befestigt, was problemlos funktionierte.

Diese Problemstellung wurde in dieser Arbeit aus Zeitgründen nicht weiter verfolgt. Daher könnte diese Problemstellung für nachfolgende Arbeiten interessant sein.

\subsubsection{Befestigung von Flex-Partikel an Flex-Partikel}

Grundsätzlich kann ein Flex-Partikel an ein anderes Partikel befestigt werden, indem die inverse Masse des befestigten Partikels auf 0 gesetzt wird und dessen Position stets auf die Position des anderen Partikels gesetzt wird. Dann wird allerdings keine physik mehr für das befestigte Partikel simuliert. Im Rahmen dieser Arbeit wurde dies allerdings nicht erwünscht. In vielen Fällen sollten zwar zwei Flex-Objekte aneinander befestigt werden, allerdings sollten sich beide physikalisch realistisch verhalten. 

Für genau diesen Anwendungsfall bietet NVIDIA FleX bereits eine Lösung an. Mithilfe von NVIDIA FleX können physikalisch realistisch wirkende Verbindungen zwischen mehreren Flex-Objekte hergestellt werden. Solche Verbindungen heißen \textit{Soft Joints} (siehe \textit{NvFlexExtSoftJoint} aus \textit{NvFlexExt.h}).

\subsection{Kollisionserkennung}


Eine wichtige Funktionalität, die die meisten Game Engines bieten, ist ein Framework für die Erkennung von Kollisionen zwischen 3d-Modellen. 
Ein Kollisionserkennungs-Framework wird für Computerspiele häufig benötigt, beispielsweise um zu erkennen ob der Spieler in tödliche Lava fällt, ob der Spieler ein Zielgebiet erreicht hat oder ob eine geschwungene klinge ein Ziel getroffen hat. Die Programmierschnittstelle für solche Kollisionserkennungen existiert meist in der Form von \textit{Event-Bindings} (hier evt irgenwas REFERENZIEREN). 

So verhält es sich auch bei der Unreal Engine 4. Hier bieten 3D-Objekte unterschiedliche Kollisions-Events an. Zum Beispiel wird ein \textit{BeginOverlap}-Event ausgelöst, wenn sich zwei 3D-Modelle berühren oder überlappen. Beliebige Klassen können auf das \textit{BeginOverlap}-Event eines 3D-Modells hören (Event-Binding), dann werden Sie immer darüber informiert, wenn das 3D-Modell etwas berührt hat und können dann entsprechend reagieren (Spieler Leben abziehen, nächstes Level laden, oder ähnliches...).

Für chirurgische Simulatoren wird ein Kollisionserkennungs-Framework benötigt, beispielsweise um zu erkennen ob ein Skalpell ein empfindliches Organ berührt oder ob eine die Spitze einer Kanüle eine Blutader getroffen hat.

In der Unreal Integration können Flex-Objekte zwar grundsätzlich miteinander kollidieren, allerdings gibt es nicht die Möglichkeit, auf das Kollisions-Event eines Flex-Objekts zu hören (\textit{Event-Binding}) oder eine Kollision zu erkennen.

Um diese fehlende Funktionalität zu ergänzen, wird das bereits bestehende Kollisionserkennungs-Framework der Unreal Engine 4 genutzt, welches auf NVIDIA PhysX aufbaut \cite{ue4physics}. Dieses Kollisionserkennungs-Framework ist nämlich bereits sehr umfangreich und ist mittels Spacial-Data-Ansatz (REFERENZ!!!) optimiert und entsprechend effizient.

%In \cite{UE4FlexDoc} wird empfohlen, fehlende Kollisionserkennungen mit einer traditionellen Rigid Body Physics Engine zu realisieren. Weil die Unreal Engine 4 bereits solch eine Physics Engine besitzt (\cite{ue4physics}), bietet es sich an, die fehlende Kollisionserkennung mit dieser zu realisieren.

Hier kommt es uns zugute, dass bei der Unreal Integration 3D-Modelle an Flex-Objekte befestigt werden können (siehe kap \textbf{XXXSceneTree}). So können auch PhysX-Kollisionskörper für Flex-Objekte modelliert und an diese befestigt werden, so wie in Abbildung \ref{Scalpel1} zu sehen.

\bild{Scalpel1}{14cm}{Ein passender PhysX-Kollisionskörper (grünes Polygonmodel) wird an ein Flex-Asset befestigt um so die umfangreiche Kollisionserkennung der Unreal Engine nutzen zu können. Hier reicht ein ungenauer Kollisionskörper aus, weil in diesem Fall nur erkannt werden soll, ob eine virtuelle Hand nach dem Skalpell greift.}

Die separaten Kollisionskörper werden dann so konfiguriert, dass sie keine Physik simulieren. Nur die Überlappungserkennung wird genutzt, um Überlappungen und Berührungen zu erkennen.

An ein Flex-Asset können auch mehrere Kollisionskörper befestigt werden um zwischen unterschiedlichen Berührungen unterscheiden zu können. Beispielsweise um zu erkennen ob die Klinge oder der Griff eines Skalpells etwas berührt hat.

%Hier evt nochmal ein Bild mit komplexeren Kollisionskörpern für Klinge, Griff, Kanülenspitze, Hauptader usw...

%  - FlexCollisionComponent kann nur emitter-partikel zählen oder löschen
  
\subsection{Interaktion zwischen FleX-Objekte und PhysX-Objekte}

%Flex-Objekte sehen Physics-Kollisionen als World-Kollision, also als ein statisches Objekt das nicht weg schiebbar ist. Dadurch überrollen Physics-Objekte andere Flex-Objekte, so als ob ihre Masse unendlich groß wäre.
 
Die Unreal Engine 4 besitzt bereits eine traditionelle Physics Engine für Rigid Bodies, die auf NVIDIA PhysX basiert \cite{ue4physics}. Mithilfe der Unreal Integration können also  FleX-Simulationen und PhysX-Simulationen gleichzeitig ausgeführt werden. Nun stellt sich die Frage, ob und wie elastische  FleX-Objekte mit PhysX-Objekte interagieren können.

Bei der verwendeten Unreal Integration können PhysX Objekte grundsätzlich mit FleX Objekte kollidieren. Allerdings üben Flex Objekte keine Kräfte auf PhysX Objekte aus. FleX Objekte sehen PhysX Objekte als statische Kollisionskörper, die nicht verschoben werden können. Dies führt zu Situationen, wie in Abbildung \ref{PhsXInteraction} links abgebildet: Kollidiert ein PhysX Objekt (weiße Kugel) mit einem Flex Objekt (blaue Kugel), wird das FleX Objekt vom PhysX Objekt ungehindert weg geschoben oder gar überrollt, wie in der Abbildung zu sehen. Weil ein FleX Objekt keine Reaktionskraft auf das PhysX Objekt ausüben kann, bewegt sich das PhysX Objekt ungehindert weiter, als würde überhaupt keine Kollision mit einem anderen Objekt stattfinden.

\bild{PhsXInteraction}{10cm}{Links: Das PhysX Objekt (weiße Kugel) überrollt ungehindert das elastische FleX Objekt (blaue Kugel), weil FleX Objekte keine Kraft auf PhysX Objekte ausüben. Rechts: Die fehlende Reaktionskraft auf das PhysX Objekt wird anhand der Verformung des Flex-Objekts ausgerechnet und angewandt. Nun prallt das PhysX Objekt vom Flex Objekt ab und verursacht nur eine geringe Verformung.}

Um dieses Problem zu lösen, muss die fehlende Reaktionskraft, die auf auf das PhysX Objekt wirkt, berechnet und angewandt werden. 
%Im Rahmen dieser Arbeit wurden hierfür eine vereinfachte Methode entwickelt. 
%Der Resultierende Kraftvektor ergibt sich aus der Verformung, die das PhysX Objekt auf das Flex Objekt
Im Rahmen dieser Arbeit wurde der Vektor der fehlenden Reaktionskraft so berechnet, wie in \cite{VRSim20}, Kapitel 6 (\textit{Haptic Feedback}). Dieser einfache Ansatz basiert auf der folgenden Idee: 

Wenn ein PhysX Objekt mit einem elastischem FleX Objekt kollidiert, verursacht das PhysX Objekt eine Verformung beim FleX Objekt. Vereinfacht lässt sich sagen: Je stärker die Verformung und je größer die Fläche der Verformung, desto stärker die Reaktionskraft auf das PhysX Objekt. Für die Flex Partikel des Flex Objekts heißt das: Je stärker die Partikel verschoben werden und je mehr Partikel verschoben werden, desto stärker ist die Reaktionskraft. Also müssen nur die Partikelverschiebungsvektoren ermittelt, umgedreht und summiert werden um einen finalen Kräftevektor zu erhalten, der sich wie gewünscht verhält. 
%Dabei werden die Partikelverschiebungsvektoren mit den Massen der verschobenen Partikel gewichtet. Dadurch werden schwerere FleX Objekte geringer verschoben.

Zusätzlich wird der Kräftevektor mit dem \textit{Stiffness} Parameter des Flex Objekts gewichtet.
Der Kräftevektor wird dann mithilfe eines einfachen Funktionsaufrufs an die PhysX Simulation übergeben. Danke des gegebenen PhysX Frameworks wirkt sich weiterhin auch die Masse des PhysX Objekts auf die Simulation aus: Je schwerer ein PhysX Objekt, desto stärker kann es Flex Objekte eindrücken.

\subsection{Kräfte und Momente}

Eine Funktionalität, die einige Game Engines anbieten, ist die Möglichkeit per Funktionsaufruf Kräftevektoren auf einzelne Körper wirken zu lassen. 
%Diese Funktionalität steht bei Game Engines als Funktion in der Form \textit{AddForce(FVector* ForceVector)} zur Verfügung, wie auch bei der Unreal Engine 4 (REEEEF). 

Diese Funktionalität wird meist genutzt um kräftebasierte Effekte oder Systeme zu programmieren. Beispielsweise können Kräfte auf Körper, die sich innerhalb einer Explosion befinden, angewandt werden, damit sie von der Explosion weg geschleudert werden. In REEEEEFFFF wird diese Funktionalität genutzt, um Auftriebskräfte auf schwimmende Objekte wirken zu lassen. 
Außerdem können mit dieser Funktionalität realistische Regelsysteme implementiert werden, die mit Kräften Körper balancieren oder zu einer Zielkonfiguration bewegen. In dieser Arbeit wird solch ein kräftebasiertes Regelsystem implementiert und dient als wichtige Grundlage für die Interaktion mit Soft Bodies in virtueller Realität ohne haptisches Feedback (siehe Kapitel \ref{sec_FSystem}).

%Bei der verwendeten Unreal Engine mit Flex Integration gibt es nicht die Möglichkeit, Kräfte auf einzelne Flex-Objekte oder Flex-Partikel wirken zu lassen.

Die NVIDIA FleX Bibliothek bietet zwar die Möglichkeit an, Kraftfelder zu erstellen (\textit{NvFlexExtForceField}), allerdings gibt es nicht die Möglichkeit, Kräfte oder Momente gezielt auf einzelne Flex-Objekte oder Partikel wirken zu lassen. %Die Kräftefelder definieren nur einen Bereich, in dem konstante Kräftevektoren im Raum verteilt sind. Dann wirkt auf alle Partikel, die sich innerhalb eines Kräftefeldes befinden, eine Kraft, abhängig von den Partikelpositionen.

%Idee und Ansatz:
Eine einfache Möglichkeit eine Kraft auf ein Partikel wirken zu lassen, ist die Manipulation der Partikelgeschwindigkeiten, so wie es auch in \cite{PBD} getan wird. Um eine Kraft, die auf ein Partikel wirken soll, zu simulieren, wird eine Geschwindigkeitsänderung, $\Delta\textbf{v}$, zur aktuellen Geschwindigkeit, $\textbf{v}$, des Partikels hinzu addiert. So kann die Flex-Simulation ungestört weiterlaufen und alle Constraints
%, wie das Kollisions-Constraint, 
wirken sich weiterhin auf die simulierten Partikel aus.

%Methode
\subsubsection{Kräfte}
Gegeben sei eine Kraft, $\textbf{F}$, die auf ein Flex-Objekt, das aus $n$ Partikeln besteht, wirken soll. Dann wird $\textbf{F}$ in $n$ gleichgroße Partikelkräfte, $\textbf{F}_i = \textbf{F} / n$ unterteilt. Jede Partikelkraft, $\textbf{F}_i$, wird dann auf ein Partikel, $i$, mit einer Punktmasse von $m_i$, angewandt.

Weil wir es mit Punktmassen zu tun haben, gilt für die Partikelkraft:

\begin{equation}
\textbf{F}_i = m_i \cdot \textbf{a} = m_i \dfrac{\Delta \textbf{v}_i}{\Delta t}
\label{form_F}
\end{equation}

Also ergibt sich die Geschwindigkeit, $\Delta \textbf{v}_i$, die zur Geschwindigkeit des Partikels addiert werden muss durch:

\begin{equation}
\Delta \textbf{v}_i = \dfrac{\textbf{F}_i}{m_i}\Delta t
\label{form_dv}
\end{equation}

Wobei $\Delta t$ der derzeitige Zeitschritt der Flex-Simulation ist. 

%Um eine Kraft auf ein komplettes Flex-Objekt zu wirken, wird $\Delta \textbf{v_i}$ auf all seine Partikel angewandt. 
%Um die gesamte Kraft, die auf ein Flex-Objekt wirkt, zu berechnen, müssen alle Partikelkräfte, $F_i$ summiert werden.

Mit dieser einfachen Methode können Flex-Objekte realistisch umher geschoben werden. Wird eine Kraft von $(0 , 0 , 9.81 )$ Newton auf ein Flex-Objekts mit einer Masse von 1 kg angewandt, wirkt es schwerelos (bei $g=(0 , 0 , -9.81 )$). Das zeigt, dass alle Einheiten korrekt berechnet wurden.

%Die Masse eines Flex-Objekts ergibt sich durch die Summe all seiner $n$ Partikelmassen, beziehungsweise durch $n \cdot m_p$, wenn alle Partikelmassen, $m_p$, gleich groß sind.

\subsubsection{Momente}

Wirkt während eines Simulationsschritts ein Moment, $M$, auf ein Flex-Objekt, müssen auf all seine Partikel Winkelgeschwindigkeiten, $\Delta \omega_i$, hinzu addiert werden. Wie bei der Kraft auch, zerlegen wir $M$ in $n$ gleichgroße Partikelmomente, $M_i=M/n$ und betrachten nun kleinere Momente, die auf Punktmassen wirken.

%Zunächst wird die Winkelgeschwindigkeit, $\Delta \omega$, berechnet. 
Die Berechnung von $\Delta \omega_i$ erfolgt wie zuvor, nur im rotatorischem Sinne (Gleichung \ref{form_omega}):

\begin{equation}
\begin{split}
M_i = m_i   \dot{\omega}_i = m_i \dfrac{\Delta \omega_i}{\Delta t} \\
\Rightarrow  \Delta \omega_i = \dfrac{M_i}{m_i} \Delta t
\end{split}
\label{form_omega}
\end{equation}

Um die Rechenkomplexität zu senken, gehen wir davon aus, dass alle Partikel die selbe Masse haben, wodurch alle Partikel um die selbe Winkelgeschwindigkeit ($\Delta \omega_i$) rotiert werden müssen. 

Neben der Größe des Moments, $M_i$, sei auch eine örtlich gebundene Achse definiert, die angibt in welche Richtung das Drehmoment wirkt. Diese Achse besteht aus einem normalisierten Richtungsvektor, $\textbf{e}$, der sich an der Position, $\textbf{c}$, befindet (siehe Abbildung \ref{moment}). $\textbf{e}$ und $\textbf{c}$ definieren also die örtlich gebundene Achse, um die sich das Flex-Objekt drehen wird, aufgrund des wirkenden Drehmoments. Das bedeutet, alle $n$ Partikel sollen sich nun zusätzlich mit einer Winkelgeschwindigkeit von $\Delta \omega_i$ um diese Drehmomentachse drehen.

Nun muss berechnet werden, in welche vektorielle Richtung, $\Delta \textbf{v}_i$ sich ein Partikel $i$ bewegen muss, damit es sich mit der gewünschten Winkelgeschwindigkeit, $\Delta \omega_i$, um die Drehmomentachse dreht. Dabei habe das Partikel die Position $\textbf{p}_i$. Abbildung \ref{moment} visualisiert diese Problemstellung.

\bild{moment}{6cm}{Das Partikel $i$ muss sich zusätzlich in die Richtung $\textbf{d}$ bewegen, damit es damit beginnt, sich um die Drehmomentachse zu drehen. Die Drehmomentachse habe die Position $\textbf{c}$ und Ausrichtung $\textbf{e}$}


$\Delta \textbf{v}_i$ besteht aus einer Geschwindigkeit, $s=|\Delta \textbf{v}_i|$ und einer Bewegungsrichtung, $\textbf{d}$, mit $|\textbf{d}|=1$. Das heißt es gilt $\Delta \textbf{v}_i = s \cdot \textbf{d}$.

$s$ ist die Umfangsgeschwindigkeit des Partikels, um die Drehmomentachse und ist abhängig von der Winkelgeschwindigkeit $\Delta \omega_i$ (siehe Gleichung \ref{form_speed}).

\begin{equation}
s = \Delta \omega_i \cdot r
\label{form_speed}
\end{equation}

$r$ ist dabei die kürzeste Entfernung, die das Partikel zur Drehmomentachse hat.
Weil $|\textbf{e}|=1$, kann $r$ aus dem folgenden Skalarprodukt berechnet werden (siehe Gleichung \ref{form_r}):

\begin{equation}
r = ||\textbf{e} \cdot \textbf{u}_i||
\label{form_r}
\end{equation}

-Mit $\textbf{u}_i=\textbf{p}_i-\textbf{c}$. 

Der Richtungsvektor, $\textbf{d}$, muss orthogonal zu $\textbf{u}_i$ und $\textbf{e}$ sein und eine Länge von 1 haben. Also kann $\textbf{d}$ mit Gleich \ref{form_dir} berechnet werden:

\begin{equation}
\textbf{d} = unit(\textbf{u}_i \times \textbf{e} )
\label{form_dir}
\end{equation}

Wobei mit $unit(...)$ der Einheitsvektor aus dem Kreuzprodukt $\textbf{u}_i \times \textbf{e} $ gemeint ist.

Schlussendlich ergibt sich die Geschwindigkeit, die zur Partikelgeschiwindigkeit hinzu addiert werden muss durch (Gleichung \ref{form_momentfinal}):

\begin{equation}
\Delta \textbf{v}_i =  \dfrac{M_i}{m_i} \Delta t ||\textbf{e} \cdot \textbf{u}|| \cdot unit(\textbf{u}_i \times \textbf{e} )
\label{form_momentfinal}
\end{equation}

Auch mit diesem Ansatz konnten optisch realistische Ergebnisse erzielt werden.

%TODO: Kurz erläutern wie das funktioniert und was Probleme sind (Partikel wollen sich immer bisl weg von Achse bewegen, wodurch innere Spannungen auftreten, die con constraints aber gelöst werden...

%Mit diesem Ansatz können FleX-Objekte mithilfe von Drehmomenten in Rotationen versetzt werden. Weil hierbei die Partikel pro Zeitschritt, $\Delta t$, auch einen kleinen Schritt von der Rotationsachse weg bewegt werden, neigen besonders weiche Soft Bodies dazu, sich geringfügig auszudehnen. Dieser Effekt kann mit kleineren Zeitschritten verringert werden.
