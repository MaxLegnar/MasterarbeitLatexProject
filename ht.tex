\chapter{NVIDIA FleX und Unreal Engine 4 für Serious Games}
\label{chap_Flex_Engine}

In Kapitel \ref{chap_Flex_Engine} wird die verwendete Unreal Engine 4 mit FleX-integration evaluiert und wenn nötig verbessert. Die Evaluation dient dazu, einen Eindruck davon zu bekommen, wie gut die Software für die Entwicklung von Serious Games im medizinischen Bereich geeignet ist und ob noch fehlende Funktionalitäten hinzugefügt werden müssen. 

Wenn eine fehlende Funktionalität entdeckt wird, die für die Entwicklung von Serious Games unverzichtbar ist, wird direkt präsentiert, wie die fehlende Funktionalität implementiert wurde.

%nicht ändern, nur erweitern:
%Im Rahmen dieser Arbeit wird stets darauf geachtet, den Source Code der Unreal Integration nicht zu verändern. 
In dieser Arbeit wurden fehlende Funktionalitäten nur durch hinzufügen neuer Softwareelemente realisiert, nicht durch Veränderung der zugrundeliegenden Software. Dadurch können neue Versionen der Unreal Integration problemlos verwendet werden, durch einfaches Austauschen. 
%So soll die Qualitätsanforderung \textit{Modularität} eingehalten werden (siehe Kapitel \textbf{XXX}).


\section{Performance}
\label{sec_performance}

%\subsubsection{NVIDIA FleX}
NVIDIA FleX zeichnet sich laut diversen Quellen (\cite{FlexD3D}, \cite{UPP}, HIER NOCH MEHR REIN!) durch eine besonders gute Performance aus, wobei in \cite{FlexD3D} genauer darauf eingegangen wird, welchen Einfluss unterschiedliche Größen auf die Geschwindigkeit des Flex-Solvers haben. 

Laut \cite{FlexD3D} wirkt sich die Partikelanzahl weniger stark auf die Performance aus, wie die Anzahl und Komplexität der verwendeten Constraints oder die verwendeten Simulationsparameter. Befinden sich beispielsweise nur Soft Bodies in einer Szene, muss der Solver deutlich weniger unterschiedliche Constraints lösen, als in einer Szene, in der sich Soft Bodies, Flüssigkeiten und Stoffe befindet.

%Die Constraints \textbf{X, X und X} sind beispielsweise deutlich rechenaufwändiger, als ein einfaches \textbf{X-Constraint} (siehe \cite{FlexD3D}).% und wirken sich daher stärker auf die Rechenzeit aus.

Im Rahmen dieser Arbeit wurde die Performance von NVIDIA FleX in Verbindung mit Unreal Engine 4 ausführlich untersucht. In diesem Kapitel (\ref{sec_performance}) werden die Einflussgrößen präsentiert, die den größten Einfluss auf die Performance hatten.

\subsubsection{Verwendete Hardware}

Für diese Arbeit und für alle durchgeführten Messungen und Tests stand die Hardware aus Tabelle \ref{table_hardware} zur Verfügung.

%\clearpage

\begin{table}[hbt!]
\centering
\caption{Die verwendete Hardware.}
\label{table_hardware}
\begin{tabular}{l|l}
 \hline
CPU & Intel Core i7-9700K  \\ \hline
GPU & NVIDIA GTX 1070 - 8GB GDDR5      \\ \hline
RAM & 32GB DDR4            \\ \hline
\end{tabular}
\end{table}

%Die verwendete Grafikkarte gehört zur vorletzten Generation der NVIDIA Grafikkarten und ist somit weniger aktuell und nicht übermäßig stark.

%% Please add the following required packages to your document preamble:
%% \usepackage{booktabs}
%\begin{table}[]
%\centering
%\caption{Einige Boid-Erhaltungsmessungen. Der Verlust von Boids konnte eindeutig nachgewiesen werden. Vor allem bei der Verteilung in zwei Zellen traten massive Verluste auf. }
%\label{Erhaltungsmessungen}
%\begin{tabular}{@{}llll@{}}
%\toprule
%\begin{tabular}[c]{@{}l@{}}Anzahl der\\ Wahrnehmungsvektoren\end{tabular} & Transportmethode                                                               & \begin{tabular}[c]{@{}l@{}}absoluter \\ Verlust\end{tabular} & \begin{tabular}[c]{@{}l@{}}prozentualer\\ Verlust\end{tabular} \\ \midrule

\subsubsection{Gemischte Simulationen}

Um einen ersten Überblick von der Performance zu bekommen, wird zunächst eine Szene simuliert, in der sich mehrere unterschiedliche Objektarten befinden. Dadurch wird des FleX-Solver stark belastet, weil er viele unterschiedliche Constraints lösen muss. Dazu gehören beispielsweise Shape Constraints (Soft- und Rigid Bodies), Spring-Constraints (Stoff-Objekte), Flüssigkeiten (Density Constraints), sowie Kollisions Constraints und Friction Constraints.

%\bild{WaterInteraction}{10cm}{Mehrere Objektarten interagieren auf realistische Weise miteinander. Werkzeuge (Skalpelle) werden von der Flüssigkeit weggespült und Körper, die eine geringere Dichte als die Flüssigkeit haben, schwimmen.}

\bild{WaterShaderPerformance}{14cm}{Mehrere Objektarten interagieren auf realistische Weise miteinander. Wird ein aufwändiger Shader für die Fluid-Partikel verwendet, kommt die GPU schnell an ihre Grenzen und die \ac{FPS} werden deutlich verringert.}

Die Simulationsparameter werden außerdem so gewählt, dass die Simulation möglichst akkurat ausgeführt wird, wodurch der FleX-Solver ebenfalls stärker belastet wird. Die gewählten Simulationsparameter wurden so wie in \cite{BreastBiopsy} gewählt. Diese Parametrisierung hat sich nämlich auch in \cite{PBDKidney} und \cite{VRSim20} bewährt um Gewebe akkurat zu simulieren.

Die verwendeten Simulationsparameter. sowie alle Messergebnisse sind in Tabelle \ref{table_mixed_sim} zu sehen.

\begin{table}[hbt!]
\centering
\caption{Simulationsparameter und Messergebnisse der simulierten Szene.}
\label{table_mixed_sim}
\begin{tabular}{l|l}
 \hline
Partikelradius & 1 cm  \\ \hline
Simulation Substeps & 3      \\ \hline
Substep Iterations & 9            \\ \hline
Anzahl Partikel & 32021            \\ \hline
Davon Fluid Partikel & 16384	\\ \hline
Anzahl Shape-Constraints & 1214		\\ \hline
Anzahl Federn & 15360 		\\ \hline
Self Collision & aktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
\textbf{Solve Sync Time (CPU)} & \textbf{0,35 ms}
\end{tabular}
\end{table}

Der Wert \textit{Solve Sync Time} gibt an, wie lange die CPU gewartet hat, bis die FleX Simulation für einen Frame von der GPU abgearbeitet wurde. Das heißt dass der FleX Solver wahrscheinlich noch schneller gearbeitet hat, als angegeben, weil die Datentransferzeiten zwischen CPU und GPU in den Messungen enthalten sind. Dennoch ist dies ein gutes Maß dafür, wie schnell die FleX Simulation ist.

Das Ergebnis von 0,35 ms ist zufriedenstellend. Die GPU hat dadurch noch genügend Zeit um die Szene mit 60-120 \ac{FPS} bei 1080p zu rendern, solange einfache Rendertechniken und mittelmäßig komplexe Shader eingesetzt werden. 

Was in dieser Arbeit besonders auffiel, ist dass das Rendern von simulierten Flüssigkeiten besonders rechenintensiv werden kann. Wird die Flüssigkeit mit aufwändigen Wasser Shadern gerendert, so wie in Abbildung \ref{WaterShaderPerformance} rechts, Kann dies zu deutlich weniger \ac{FPS} führen. Es ist also ratsam, besonders effiziente Rendertechniken für simulierte Flüssigkeiten einzusetzen.

Weil für chirurgische Simulatoren vor allem das Simulieren von Weichkörpern interessant ist, werden die nächsten Tests nurnoch mit Soft Bodies simuliert, die aus clustered Shape-Constraints bestehen.

%\begin{table}[]
%\centering
%\caption{Neue Objektarten wurden Schrittweise hinzugefügt}
%\label{table_mixed_res}
%\begin{tabular}{l|rrrr|l}
%\textbf{Hinzugefügt} & \multicolumn{1}{l}{\textbf{Partikelanzahl}} & \multicolumn{1}{l}{\textbf{Shape Constraints}} & \multicolumn{1}{l}{\textbf{Fluid Partikel}} & \multicolumn{1}{l|}{\textbf{Distance Constraints}} & \textbf{Solve Sync Time} \\ \hline
%Nur Soft Bodies      & 12548                                       & 1209                                           & 0                                           & 0                                                  & 0.16                     \\
%+ Flüssigkeit        & 28932                                       & 1209                                           & 16384                                       & 0                                                  & 0.17                     \\
%+ Stoff              & 31494                                       & 1209                                           & 16384                                       & 15360                                              & 0.31                     \\
%+ Rigid Bodies       & 32021                                       & 1214                                           & 16381                                       & 15360                                              & 0.35                    
%\end{tabular}
%\end{table}
\clearpage
\subsubsection{Simulationsparametrisierung}

Für alle Messungen, die in diesem Kapitel präsentiert werden, wurden die Einstellungen aus Tabelle \ref{table_soft_param} verwendet.

\begin{table}[hbt!]
\centering
\caption{Verwendete Parameter für diesen Versuch}
\label{table_soft_param}
\begin{tabular}{l|l}
 \hline
Partikelradius & 1 cm  \\ \hline
Simulation Substeps & variierend (2-3)      \\ \hline
Substep Iterations & variierend (3-9)            \\ \hline
Simulierte Objektarten &  nur Soft Bodies mit Shape Constraints\\ \hline
Self Collision & deaktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
\end{tabular}
\end{table}

%TODO: Auf Substeps und Substep iterations eingehen!!!

In Abbildung \ref{figure3} ist zu sehen, wie schnell unterschiedlich viele Soft Bodies simuliert werden konnten, bei unterschiedlichen Simulationsparametern. %Für alle Simulationen wurde ein Partikelradius von 1 cm verwendet. 
Mit den Simulationsparametern von der blauen Kurve können bereits erste optisch realistisch wirkende Simulationen ausgeführt werden, wobei sich damit keine akkuraten Gewebeverformungen simulieren lassen. Wie man sieht, steigt die Blaue Kurve nur sehr schwach an (Steigung ca. $10^{-5}$). Selbst wenn über 100 Tausend Partikel (26 Soft Bodies, 10478 Cluster) simuliert werden, benötigt der FleX-Solver nur 1,12 Millisekunden für einen Simulationsschritt. Die Szene konnte daher immer mit 120 FPS gerendert werden.
\clearpage
\bild{figure3}{11cm}{Die blaue Kurve zeigt die Simulationsgeschwindigkeit von FleX bei einfachen (kleinen) Simulationsparametern. Die rote Kurve zeigt die die Simulationsgeschwindigkeit von FleX bei einer akkurateren Simulation mit größeren Simulationsparametern.}

Wird die Simulation allerdings akkurater ausgeführt, mit den Parametern der roten Kurve (gut für akkurate Gewebesimulationen), wird die Lösungsgeschwindigkeit ab einer kritischen Partikelanzahl deutlich langsamer. Im Diagramm \ref{figure3} erkennt man sehr deutlich, wie die rote Kurve ab einer Partikalanzahl von etwa 60 Tausend nach oben schießt. Davor läuft die Simulation nahezu genauso schnell wie zuvor, bei geringeren Simulationsparametern.
%, mit einer Steigung von ca. 0,28.
Abbildung \ref{figure4} zeigt welche Auswirkung die steigende Simulationszeiten auf die Renderfrequenz hatten. Hierzu sei gesagt, dass in dieser Szene mittelmäßig komplexe Shader und Grafikeinstellungen eingesetzt wurden.

\bild{figure4}{12cm}{...}

Das plötzliche Ansteigen der Simulationszeiten bei der akkurateren Simulation weist auf eine Hardwaregrenze hin, bei der nicht mehr genügend Hardwareressourcen zur Verfügung stehen um weiterhin effizient arbeiten zu können. Der Grafikspeicher der Grafikkarte wurde allerdings niemals voll ausgenutzt (maximal 4 von 8 GB wurden belegt). Die Grenze von 60 Tausend Partikeln konnte im Anwendungsteil dieser Arbeit nie überschritten werden. Im finalen chirurgischen Simulator mussten lediglich 12000 Partikel simuliert werden (siehe Kapitel XXX). Dadurch konnten problemlos zusätzliche Simulationen ausgeführt und komplexere Rendertechniken eingesetzt werden, ohne negativen Einfluss auf die FPS.



% ------ HIER EVT FIGURE 6 präsentieren, sprengt aber evt den Rahmen!!! -----------------------

%Als nächstes wurde eine Szene mit konstanter Partikelanzahl simuliert, während einzelne Simulationsparameter stufenweise angehoben wurden.
%figure6

\clearpage
\subsubsection{Cluster Konfigurationen}


%Zeige: Viele kleine Cluster vs wenig große Cluster -> Viele kleine Cluster ist deutlich performanter als wenige große Cluster. WIESO? -> FleX löst Constraints parallelisiert. Die Lösung eines einzelnen Constraints ist eine sequenzielle Operation. Je größer ein Cluster, desto mehr Partikel beinhaltet. Je mehr Partikel in einem Cluster, desto rechenintensiver ist die Lösung des Shape Constraints!

%In diesem Kapitel wird untersucht welchen Einfluss unterschiedliche Cluster Konfigurationen auf die Simulationsperformance von Soft Bodies, die aus Shape-Constraints bestehen, haben. 

In diesem Kapitel wird untersucht welchen Einfluss unterschiedliche Cluster Konfigurationen auf die Performance von Shape-Constraint-basierten Soft Body Simulationen haben. 

Hierfür wurden zwei sehr ähnliche FleX Assets modelliert, die sich nur durch ihre Cluster Konfigurationen unterscheiden (siehe Tabelle \ref{table_clusters}). Der wesentliche Unterschied zwischen den beiden Assets ist, dass Asset A aus vielen kleinen Clustern besteht, während Asset B aus wenigen großen Clustern besteht, so wie in Abbildung \ref{Clusters} zu erkennen. 

\bild{Clusters}{14cm}{Das selbe FleX-Asset mit zwei unterschiedlicher Cluster Anordnungen. Die Cluster werden als Koordinatensysteme visualisiert. Das linke Asset hat viele kleine Cluster, während das Rechte wenige große Cluster besitzt. Mit beiden Assets können optisch realistisch wirkende Deformationen simuliert werden, allerdings gibt es große Performance Unterschiede.}

Eine erste intuititive Vermutung wäre nun, dass Asset B performanter simuliert werden kann, weil hier weniger Shape-Constraints gelöst werden müssen. Aus den Messergebnissen (siehe Tabelle \ref{table_clusters}) geht allerdings das Gegenteil hervor: Bei Asset B wurde eine 70 mal größere Solve Sync Time gemessen als bei Asset A. 
%Dadurch konnte Asset B nurnoch mit 46 FPS gerendert werden, während Asset A bei 120 FPS gemessen wurden.

%\begin{table}[]
%\centering
%\caption{Verwendete Parameter für diesen Versuch}
%\label{table_soft_assets}
%\begin{tabular}{l|l}
% \hline
%Partikelradius & 1 cm  \\ \hline
%Simulation Substeps & 3     \\ \hline
%Substep Iterations & 9            \\ \hline
%Simulierte Objektarten &  nur Soft Bodies mit Shape Constraints\\ \hline
%Self Collision & deaktiviert \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
%\end{tabular}
%\end{table}

\begin{table}[hbt!]
\centering
\caption{Messergebnisse des Cluster Versuchs. Assets mit mehr und dafür kleineren Clustern performen deutlich besser.}
\label{table_clusters}
\begin{tabular}{lcc}
                                         & \textbf{Asset A}      & \textbf{Asset B}      \\ \hline
\multicolumn{1}{l|}{Partikelradius}      & 1                     & 1                     \\
\multicolumn{1}{l|}{Simulation Substeps} & 3                     & 3                     \\
\multicolumn{1}{l|}{Substep Iterations}  & 9 					 & 9 				     \\
\multicolumn{1}{l|}{Partikelanzahl}      & 23815                 & 23815                 \\
\multicolumn{1}{l|}{Clusterradius}       & 6                     & 20                    \\
\multicolumn{1}{l|}{Clusteranzahl}       & 133                   & 18                    \\
\multicolumn{1}{l|}{Partikel / Cluster}  & 179                   & 1323                  \\ \hline
\multicolumn{1}{l|}{Solve Sync Time}     & 0,24 ms               & 16,83 ms              \\
\multicolumn{1}{l|}{FPS}                 & 120                   & 46   
\end{tabular}
\end{table}

%Aus diesen Messergebnissen lässt sich eine wichtiger Grundsatz ableiten: Je mehr Shape Constraints ein 

Die GPU kommt also offenbar bei der Verarbeitung von wenigen großen Clustern schnell an ihre Grenzen.
%Das hat damit zu tun, wie NVIDIA FleX die Partikel und Constraints verarbeitet. 

Hierfür gibt es zwei Ursachen: Zum Einen ist die Verarbeitung der Shape Constraints laut \cite{FlexD3D} aufwändig, weil hierbei die Momentenmatrizen der Cluster polar zerlegt werden müssen. Das ist besonders rechenintensiv.

Zum Anderen verarbeitet NVIDIA FleX Shape Constraints nach der sogenannten Constraint otientierten Methode. Um die Simulation zu verarbeiten, wird in \cite{UPP} zwischen zwei unterschiedlichen Verarbeitungsansätzen unterschieden: Partikel orientiert und Constraint orientiert. 

Beim Partikel orientierten Ansatz werden alle Partikel parallel verarbeitet und für jedes Partikel werden die Constraints, die das Partikel beeinflussen, sequenziell verarbeitet. 

Beim Constraint orientierten Ansatz werden alle Constraints parallel verarbeitet und alle Partikel, die ein Constraint beeinflusst, werden sequenziell verarbeitet, beziehungsweise verschoben. 

NVIDIA FleX setzt beide Verarbeitungsansätze ein, je nachdem um welche Art von Constraint es sich handelt. Shape-Constraints werden mit dem Constraint orientierten Ansatz verarbeitet \cite{FlexD3D}. Weil für jedes Cluster ein entsprechendes Shape-Constraint gelöst wird, kann man sich also vorstellen, dass alle Cluster parallel verarbeitet werden, während alle Partikel, die sich innerhalb eines Clusters befinden, sequenziell verarbeitet werden. Je größer ein Cluster, desto mehr Partikel beinhält es und desto mehr Partikel müssen sequenziell verarbeitet werden. 

Deswegen ist es besser viele kleine Cluster zu verwenden. So wird mehr Arbeit parallelisiert (viele Cluster) und es muss weniger sequenziell verarbeitet werden (wenig Partikel pro Cluster). Außerdem bringt dies den zusätzlichen Vorteil mit sich, dass sich ein Soft Body, das aus vielen Clustern besteht, vielfältiger verformen lässt.



\subsubsection{Self Collision und Partikelradius}

%Fazit: Wenig Partikelüberschneidung bei Self Collision. Wichtig zu erwähnen: Führt auch zu instabilen, zitternden Zuständen! Außerdem: Je mehr Kollisionen/Kontackte existieren, desto mehr Collisions und friction constraints müssen gelöst werden.

In diesem Kapitel wird untersucht wie stark sich unterschiedliche Partikelradi auf die Simulationsperformance von Soft Bodies auswirkt. Hierfür wurde eine Szene mit den Einstellungen aus Tabelle \ref{table_self_collision} simuliert. 

\begin{table}[hbt!]
\centering
\caption{Verwendete Parameter für diesen Versuch}
\label{table_self_collision}
\begin{tabular}{l|l}
 \hline
Partikelradius & variierend  \\ \hline
Simulation Substeps & 3      \\ \hline
Substep Iterations & 9            \\ \hline
Simulierte Objekte &  10 Soft Bodies \\ \hline
Self Collision & variierend \\ \hline%Nur bei Cloth Assets aktiviert, also für 2562 Partikel		\\ \hline
Ignore Rest Collision & True\\ \hline
Shape-Constraints & 850            \\ \hline
Partikelanzahl & 26010            \\ \hline
\end{tabular}
\end{table}

Dabei wurde der Partikelradius stufenweise erhöht. 

\bild{RadiusOctupus}{14cm}{Je größer der Partikelradius, desto mehr Selbstkollisionen kommen in einem einzelnen Asset vor. Sind die Partikel zu klein, entstehen Lücken zwischen den Partikeln (links). Das sollte vermieden werden, sonst können Objekte durch solche Lücken hindurch fallen.}

Dieser Test wurde einmal mit Assets durchgeführt, bei denen \textit{Self Collision} aktiviert war und einmal mit Assets, bei denen \textit{Self Collision} deaktiviert war. Ist \textit{Self Collision} aktiviert, können die Partikel, die sich innerhalb eines Assets befinden, miteinander kollidieren, wobei bei der Ruhestellung keine Kollisionen stattfinden (Parameter \textit{IgnoreRestCollisions=True}). Ist Self Collision deaktiviert, können die Partikel des selben FleX Objekts nicht miteinander kollidieren. Nur mit den Partikeln von anderen Objektinstanzen.

Die Messergebnisse sind in Abbildung \ref{figure5} zu sehen.

\bild{figure5}{10cm}{...}

Wie man sieht entsteht ab einem Partikelradius von etwas 15 cm ein starker Performance Verlust, allerdings nur wenn Self Collision aktiviert ist. Das liegt vermutlich daran, dass sich mit wachsendem Partikelradius benachbarte Partikel immer stärker überlappen (siehe Abbildung \ref{RadiusOctupus}). Dabei entstehen immer mehr Partikelkollisionen. Ab einem bestimmten Punkt stehen nicht mehr genügend Hardwareressourcen zur Verfügung um die vielen Kollisions-Constraints zu lösen.

Solange sich die Partikel nicht zu stark überlappen (so wie in Abbildung \ref{RadiusOctupus}, Mitte), kommt FleX allerdings gut mit der Kollisionsverarbeitung zurecht, selbst wenn Self Collision aktiviert ist.


%%%%%%%%%%%%%%%% ALT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\subsubsection{Test Szenario}

%Für die Anwendungsfälle dieser Arbeit sind vor allem Soft Bodies interessant. Daher wird nun eine Szene simuliert, in der sich ausschließlich Soft Bodies befinden (siehe Abbildung \ref{PerfGTX1Scene}). 
%
%TODO: Welche Constraints verwendet und wie viele???!!!
%
%\bild{PerfGTX1Scene}{12cm}{In der Testszene befinden sich mehrere unterschiedliche Soft Bodies, die eine Treppe hinunter rollen.}
%
%Die simulierten Körper kollidierten und verformten sich dabei stets augenscheinlich realistisch.
%
%Folgenden Simulationsparameter wurden eingesetzt (siehe Abbildung \ref{PerfGTX1Set}):
%
%\bild{PerfGTX1Set}{10cm}{Die verwendeten Simulationsparamer für dies Testreihe.}
%
%Für alle Messungen wurde der Simulationsparameter \textit{Sleep Threshold} auf einen negativen Wert gesetzt, um zu verhindern, dass zu langsame Partikel von der Simulation ausgeschlossen werden.

%Alle Messungen wurden mithilfe des Befehls \textit{stat flex} ermittelt. In \cite{UE4FlexDoc} unter \url{gameworksdocs.nvidia.com/FleX/1.2/ue4_docs/FLEXUe4_Debug.html} kann nachgeschlagen werden, was die gemessenen und gezeigten Attribute bedeuten.

%\subsubsection{Messergebnisse}
%
%%Typische Frametime: 15 ms bis 17ms sind im 60 fps-Bereich (1000ms / 15 ms = 66,66… FPS)
%
%In Abbildung \ref{PerfGTX1} sind die Messdaten zu sehen, die sich ergaben.
%
%\bild{PerfGTX1}{14cm}{TEMP!!! Performance Messungen bei unterschiedlichen Partikelanzahlen mit einem Partikelradius von 10cm. Die durchschnittliche Solver Zeit steigt flach und linear mit der Partikelanzahl an.}
%
%Zu den Messdaten sei gesagt, dass \textit{Solve Sync Time} mithilfe der CPU gemessen wurde. \textit{Solve Sync Time} repräsentiert also nicht nur die Zeit, die der Flex-Solver benötigt, sondern zusätzlich die CPU-GPU Synchronisierungszeit. Dennoch ist dies ein gutes Maß für die Performance von NVIDIA Flex. 
%
%Zur gemessenen Performance: 
%Die Messungen zeigen eindeutig, dass NVIDIA Flex besonders gut für Echtzeitanwendungen geeignet ist. Selbst bei 70000 simulierten Partikeln (und 134 Soft Bodies) benötigt der Flex Solver durchschnittlich nur 1 ms zum Lösen aller Constraints, wobei er maximal 2,5 ms benötigt, was immer noch im akzeptablen Bereich für eine realistische Optik liegt. 
%
%%In Abbildung \ref{PerfGTX1} zeigt die Linie \textit{SumAvg} an, wie lange der gesamte Simulationsprozess im Durchschnitt gedauert hat. Der gesamte Simulationsprozess ergibt sich aus den Zeiten der folgenden Arbeitsschritte, summiert (Abbildung \ref{PerfStats}):
%
%%\bild{PerfStats}{12cm}{Alle gemessenen Arbeitsschritte und ihre Bedeutungen \cite{UE4FlexDoc} -> Das hier evt nur als Anlage???}
%
%Dank der beeindruckenden Geschwindigkeit des Flex-Solvers konnten alle Tests mit 120 \ac{FPS} gerendert werden, bei einer Auflösung von ca. 1080p. 
%%Mit einer Oculus Quest 2 konnte die Szene stets mit 90 FPS bei einer Auflösung von \textbf{XXX} dargestellt werden. 
%So wie in \cite{FlexD3D} bereits erwähnt, 
%%hat die Anzahl der simulierten Partikel einen geringen Einfluss auf die Geschwindigkeit des Solvers.
%skaliert die Simulationsgeschwindigkeit nur schwach mit der Partikelanzahl.



%Auch wenn die Messungen viel versprechen, wird sich erst am Ende dieser Arbeit zeigen (siehe Kapitel \ref{chap_Szenarien}), ob NVIDIA Flex für Serious Games im chirurgischen Bereich geeignet ist.

%% ----EVT TODO--------
%Dann nochmal mit kleineren Partikeln und mehr substeps simulieren, weil das besser auf chirurges-szenario passt. In einigen anderen Arbeiten wurden ja auch recht kleine radi verwendet und mehr substeps usw (könnte man auch kurz drauf verweisen, auf diese paper und argumentieren das wir daher besser auf solche szenarien achten sollten)

%%%%%%%%%%%%%%%% ALT ENDE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage
\section{Funktionalitäten}
In der Einleitung von \cite{UE4FlexDoc} wird bereits darauf hingewiesen, dass die Unreal Integration noch nicht weit genug entwickelt ist, um Gameplay-beeinflussende Physikszenarios zu erstellen. In diesem Kapitel wird genauer untersucht, welche   Funktionalitäten  die Unreal Integration bereits bietet und welche noch fehlen. 
%Hierfür gehen wir nach und nach alle funktionalen Anforderungen aus Kapitel \textbf{XXX} durch und kontrollieren, ob Anforderungen fehlen oder nur teilweise vorhanden sind.

%\subsection{Synchronisation mit Flex Simulation}

%... kommt evt raus, ist ja nicht so wichtig....

\subsection{Transformationsmanipulationen}


Game Engines verfügen in der Regel über eine umfangreiche Bibliothek für Transformationsberechnungen. So können Punkte oder Richtungen mit homogenen Transformationen manipuliert und die Transformationsmatrizen von unterschiedlichen 3D-Objekten miteinander verrechnet werden.
Dies ist eine wichtige Grundlage um 3D-Objekte bewegen, rotieren und skalieren zu können. 

Die Unreal Engine bietet hierfür den Datentyp \textit{FTransform} und die Bibliothek \textit{TransformCalculus.h} an. Jedes 3D-Objekt besitzt eine eigene Transformation, die zur Laufzeit manipuliert werden kann. Häufig werden die beiden Funktionen \textit{SetWorldTransform($T_{world}$)} und \textit{SetRelativeTransform($T_{relative}$)} genutzt um 3D-Objekte relativ zur Welt oder relativ zum derzeitigen Parent-Objekt zu bewegen.

Bei der Unreal Engine mit Flex Integration wurde das Transformations-Framework nur teilweise für Flex-Objekte angepasst. Obwohl alle FlexComponents eine eigene Transformation vom Typ FTransform besitzen, kann diese weder relativ noch absolut gesetzt werden. Die beiden Funktionen \textit{SetWorldTransform()} und \textit{SetRelativeTransform()} haben keine Auswirkung auf FlexComponents.

Diese wichtige Funktionalität muss also noch hinzugefügt werden. Dabei wird das bereits bestehende Transformations-Framework der Unreal Engine benutzt.

\subsubsection{\textit{SetWorldTransform}}

Um die Welt-Transformation eines Flex-Objekts zu ändern, müssen die Positionen all seiner Partikel mithilfe einer homogenen Transformationsmatrix, $T_{world}$, transformiert werden. Über die NVIDIA FleX Bibliothek können die lokalen Positionen, $\vec{p}_{local}$, der Partikel eines Flex-Assets 
%(\textit{float* NvFlexExtInstance::NvFlexExtAsset::particles}) % das hier evt weg machen!!!!
ermittelt werden. Das sind die lokalen Partikelpositionen des Flex-Assets, in seiner Ruheposition. Die neue Position, $\vec{p}_{new}$ eines Partikels ergibt sich dann mit Gleichung \ref{form_worldtransf}.

\begin{equation}
\vec{p}_{new} = T_{world} \cdot \vec{p}_{local}
\label{form_worldtransf}
\end{equation}

Gleichung \ref{form_worldtransf} ist im Grunde nichts anderes als die Transformation eines Punktes vom Objekt-Koordinatensystem ins Weltkoordinatensystem. Im Rahmen dieser Arbeit hat es sich als hilfreich erwiesen, die Geschwindigkeiten der transformierten Partikel auf null zu setzen, um das versetzte Flex-Objekt sofort in einen ruhigen Simulationszustand zu versetzten. 

Soll ein Flex-Objekt  über einen längeren Zeitraum entlang einer Trajektorie bewegt werden, ist es sinnvoll, die bewegten Partikel von der Flex-Simulation auszuschließen, indem ihre invertierten Massen auf null gesetzt werden. Dadurch sind die bewegten Partikel unendlich schwer und können nicht mehr von der Flex-Simulation bewegt werden \cite{PBD} \cite{UPP}. 

Weil bewegte Partikel von der Simulation ausgeschlossen werden, erscheinen bewegte Weichkörper starr. Um bewegte Weichkörper weiterhin elastisch erscheinen zu lassen, wird nur eine Teilmenge der Partikel bewegt. Dann erscheint nur ein Teil des bewegten Körpers starr und der Rest bleibt elastisch und folgt den bewegten Partikeln.

\subsubsection{\textit{SetRelativeTransform}}
\label{subsubsec_reltrans}
%Um ein Partikel relativ zu einer Parent-Szene zu bewegen (\textit{SetRelativeTransform()}), wird zunächst die allgemeine Situation aus Abbildung \ref{Transform1} betrachtet:

% eventuel streichen!
%\bild{Transform1}{10cm}{Um ein Partikel mit $T_{rel}$ relativ zu \textit{ParentScene} zu transformieren, muss das Matrixprodukt aus der Welt-Transformation von \textit{ParentScene}, $T_{parent}$, und $T_{rel}$ gebildet werden.}

Gegeben sei die Welt-Transformation einer Parent-Szene, $T_{parent}$ und die gewünschte Transformation, $T_{rel}$, die das Partikel relativ zur Parent-Szene einnehmen soll 
%(siehe Abbildung \ref{Transform1}). 
Dann kann mit Gleichung \ref{form_reltransf} die neue Weltposition, $\vec{p}_{new}$, des Partikels berechnet werden.

\begin{equation}
\vec{p}_{new} = T_{parent} \cdot T_{rel} \cdot \vec{p}_{local}
\label{form_reltransf}
\end{equation}

Gleichung \ref{form_worldtransf} und \ref{form_reltransf} sind einfache homogene Matrix-Vektor-Multiplikationen und sollten daher effizient von heutiger Hardware gelöst werden können. Außerdem kann die Berechnung der Partikelpositionen parallelisiert werden.

\subsection{Befestigung von FleX Objekten}
\label{subsec_attach}

%Für gewöhnlich arbeiten Game Engines mit sogenannten Scene Trees um 3D-Objekte hierarchisch zu organisieren (REFERENZ). Dabei repräsentiert jedes 3D-Objekt einen Knoten im Scene Tree. 3D-Objekte werden aneinander befestigt, so das sich eine Baumstruktur bildet, in der die Kinderobjekte an ihre Elternobjekte befestigt sind. Ändert sich die Transformation eines Elternknotens, bewegen sich all seine Kinderobjekte mit. 
%
%\bild{SceneTree}{8cm}{Alle Szenen und 3D-Objekte werden in einem Szene Tree organisiert}
%
%Die Struktur eines Scene Trees lässt sich zur Laufzeit eines Spiels ändern, indem 3D-Objekte per Funktionsaufruf von ihren Eltern gelöst (\textit{Detach()}) oder an andere 3D-Objekte befestigt (\textit{AttachTo(NewParent)}) werden. Diese beiden Funktionen werden in Computerspielen häufig benötigt, beispielsweise damit der Spieler 3D-Objekte aufheben (\textit{AttachTo(Hand)}) und wieder loslassen (\textit{Detach()}) kann.

\subsubsection{Befestigung von Flex-Partikeln an Szenen}

In der Unreal Integration können mehrere Flex-Partikel an eine Szene befestigt werden. Hierfür stehen allerdings nur Funktionen zur Verfügung, bei denen alle Partikel, die sich innerhalb einer Kugel befinden, befestigt werden. Auf Grundlage dieser Funktion wurden daher weitere Funktionen angelegt, um einzelne Partikel via Partikelindex an SceneComponents befestigen zu können.

Um ein Flex-Partikel an eine Szene zu befestigen, muss dessen inverse Masse, $w$, auf 0 gesetzt werden. Dann hat das Partikel eine unendlich große Masse und kann nicht mehr von der FleX Simulation bewegt werden. 
Gegeben sei außerdem die Position, $\vec{p}_{local}$, die das Partikel relativ zur Szene beibehalten soll. Immer wenn sich die Szene bewegt, wird die Weltposition, $\vec{p}_{new}$, des befestigten Partikels so verändert, dass die relative Position $\vec{p}_{local}$ unverändert bleibt.
$\vec{p}_{new}$ kann mithilfe von Gleichung \ref{form_reltransf} aus Kapitel \ref{subsubsec_reltrans} berechnet werden.

%Des weiteren musste eine Funktion zum Lösen von befestigten Partikel angelegt werden (\textit{DetachAllFlexParticles()}), weil auch solch eine Funktionalität fehlte.


%%% EVT noch genauer beschreiben wie genau das Befestigen funktioniert...

\subsubsection{Befestigung von Szenen an Szenen}

Erfreulicherweise unterstützt die verwendete Unreal Integration bereits das Befestigen von Szenen oder anderen 3D Objekten an ein Flex-Objekt. Allerdings drehen sich Szenen nicht mit Soft Bodies mit. Nur die Position der befestigten Szenen wird angepasst, während die Rotation unverändert bleibt. 

%Diese Problemstellung wurde im Rahmen dieser Arbeit nicht weiter verfolgt, weil hier keine Szenen an Soft Bodies befestigt werden mussten. Es wurden nur Szenen an Rigid Bodies befestigt, was problemlos funktionierte.

Diese Problemstellung wurde in dieser Arbeit aus Zeitgründen nicht weiter verfolgt. Daher könnte diese Problemstellung für nachfolgende Arbeiten interessant sein.

\subsubsection{Befestigung von Flex-Partikel an Flex-Partikel}

Grundsätzlich kann ein Flex-Partikel an ein anderes Partikel befestigt werden, indem die inverse Masse des befestigten Partikels auf 0 gesetzt wird und dessen Position stets auf die Position des anderen Partikels gesetzt wird. Dann wird allerdings keine physik mehr für das befestigte Partikel simuliert. Im Rahmen dieser Arbeit wurde dies allerdings nicht erwünscht. In vielen Fällen sollten zwar zwei Flex-Objekte aneinander befestigt werden, allerdings sollten sich beide physikalisch realistisch verhalten. 

Für genau diesen Anwendungsfall bietet NVIDIA FleX bereits eine Lösung an. Mithilfe von NVIDIA FleX können physikalisch realistisch wirkende Verbindungen zwischen mehreren Flex-Objekte hergestellt werden. Solche Verbindungen heißen \textit{Soft Joints} (siehe \textit{NvFlexExtSoftJoint} aus \textit{NvFlexExt.h}).

\subsection{Kollisionserkennung}


Eine wichtige Funktionalität, die die meisten Game Engines bieten, ist ein Framework für die Erkennung von Kollisionen zwischen 3d-Modellen. 
Ein Kollisionserkennungs-Framework wird für Computerspiele häufig benötigt, beispielsweise um zu erkennen ob der Spieler in tödliche Lava fällt, ob der Spieler ein Zielgebiet erreicht hat oder ob eine geschwungene klinge ein Ziel getroffen hat. Die Programmierschnittstelle für solche Kollisionserkennungen existiert meist in der Form von \textit{Event-Bindings} (hier evt irgenwas REFERENZIEREN). 

So verhält es sich auch bei der Unreal Engine 4. Hier bieten 3D-Objekte unterschiedliche Kollisions-Events an. Zum Beispiel wird ein \textit{BeginOverlap}-Event ausgelöst, wenn sich zwei 3D-Modelle berühren oder überlappen. Beliebige Klassen können auf das \textit{BeginOverlap}-Event eines 3D-Modells hören (Event-Binding), dann werden Sie immer darüber informiert, wenn das 3D-Modell etwas berührt hat und können dann entsprechend reagieren (Spieler Leben abziehen, nächstes Level laden, oder ähnliches...).

Für chirurgische Simulatoren wird ein Kollisionserkennungs-Framework benötigt, beispielsweise um zu erkennen ob ein Skalpell ein empfindliches Organ berührt oder ob eine die Spitze einer Kanüle eine Blutader getroffen hat.

In der Unreal Integration können Flex-Objekte zwar grundsätzlich miteinander kollidieren, allerdings gibt es nicht die Möglichkeit, auf das Kollisions-Event eines Flex-Objekts zu hören (\textit{Event-Binding}) oder eine Kollision zu erkennen.

Um diese fehlende Funktionalität zu ergänzen, wird das bereits bestehende Kollisionserkennungs-Framework der Unreal Engine 4 genutzt, welches auf NVIDIA PhysX aufbaut \cite{ue4physics}. Dieses Kollisionserkennungs-Framework ist nämlich bereits sehr umfangreich und ist mittels Spacial-Data-Ansatz (REFERENZ!!!) optimiert und entsprechend effizient.

%In \cite{UE4FlexDoc} wird empfohlen, fehlende Kollisionserkennungen mit einer traditionellen Rigid Body Physics Engine zu realisieren. Weil die Unreal Engine 4 bereits solch eine Physics Engine besitzt (\cite{ue4physics}), bietet es sich an, die fehlende Kollisionserkennung mit dieser zu realisieren.

Hier kommt es uns zugute, dass bei der Unreal Integration 3D-Modelle an Flex-Objekte befestigt werden können (siehe kap \textbf{XXXSceneTree}). So können auch PhysX-Kollisionskörper für Flex-Objekte modelliert und an diese befestigt werden, so wie in Abbildung \ref{Scalpel1} zu sehen.

\bild{Scalpel1}{14cm}{Ein passender PhysX-Kollisionskörper (grünes Polygonmodel) wird an ein Flex-Asset befestigt um so die umfangreiche Kollisionserkennung der Unreal Engine nutzen zu können. Hier reicht ein ungenauer Kollisionskörper aus, weil in diesem Fall nur erkannt werden soll, ob eine virtuelle Hand nach dem Skalpell greift.}

Die separaten Kollisionskörper werden dann so konfiguriert, dass sie keine Physik simulieren. Nur die Überlappungserkennung wird genutzt, um Überlappungen und Berührungen zu erkennen.

An ein Flex-Asset können auch mehrere Kollisionskörper befestigt werden um zwischen unterschiedlichen Berührungen unterscheiden zu können. Beispielsweise um zu erkennen ob die Klinge oder der Griff eines Skalpells etwas berührt hat.

%Hier evt nochmal ein Bild mit komplexeren Kollisionskörpern für Klinge, Griff, Kanülenspitze, Hauptader usw...

%  - FlexCollisionComponent kann nur emitter-partikel zählen oder löschen
  
\subsection{Interaktion zwischen FleX-Objekte und PhysX-Objekte}

%Flex-Objekte sehen Physics-Kollisionen als World-Kollision, also als ein statisches Objekt das nicht weg schiebbar ist. Dadurch überrollen Physics-Objekte andere Flex-Objekte, so als ob ihre Masse unendlich groß wäre.
 
Die Unreal Engine 4 besitzt bereits eine traditionelle Physics Engine für Rigid Bodies, die auf NVIDIA PhysX basiert \cite{ue4physics}. Mithilfe der Unreal Integration können also  FleX-Simulationen und PhysX-Simulationen gleichzeitig ausgeführt werden. Nun stellt sich die Frage, ob und wie elastische  FleX-Objekte mit PhysX-Objekte interagieren können.

Bei der verwendeten Unreal Integration können PhysX Objekte grundsätzlich mit FleX Objekte kollidieren. Allerdings üben Flex Objekte keine Kräfte auf PhysX Objekte aus. FleX Objekte sehen PhysX Objekte als statische Kollisionskörper, die nicht verschoben werden können. Dies führt zu Situationen, wie in Abbildung \ref{PhsXInteraction} links abgebildet: Kollidiert ein PhysX Objekt (weiße Kugel) mit einem Flex Objekt (blaue Kugel), wird das FleX Objekt vom PhysX Objekt ungehindert weg geschoben oder gar überrollt, wie in der Abbildung zu sehen. Weil ein FleX Objekt keine Reaktionskraft auf das PhysX Objekt ausüben kann, bewegt sich das PhysX Objekt ungehindert weiter, als würde überhaupt keine Kollision mit einem anderen Objekt stattfinden.

\bild{PhsXInteraction}{10cm}{Links: Das PhysX Objekt (weiße Kugel) überrollt ungehindert das elastische FleX Objekt (blaue Kugel), weil FleX Objekte keine Kraft auf PhysX Objekte ausüben. Rechts: Die fehlende Reaktionskraft auf das PhysX Objekt wird anhand der Verformung des Flex-Objekts ausgerechnet und angewandt. Nun prallt das PhysX Objekt vom Flex Objekt ab und verursacht nur eine geringe Verformung.}

Um dieses Problem zu lösen, muss die fehlende Reaktionskraft, die auf auf das PhysX Objekt wirkt, berechnet und angewandt werden. 
%Im Rahmen dieser Arbeit wurden hierfür eine vereinfachte Methode entwickelt. 
%Der Resultierende Kraftvektor ergibt sich aus der Verformung, die das PhysX Objekt auf das Flex Objekt
Im Rahmen dieser Arbeit wurde der Vektor der fehlenden Reaktionskraft so berechnet, wie in \cite{VRSim20}, Kapitel 6 (\textit{Haptic Feedback}). Dieser einfache Ansatz basiert auf der folgenden Idee: 

Wenn ein PhysX Objekt mit einem elastischem FleX Objekt kollidiert, verursacht das PhysX Objekt eine Verformung beim FleX Objekt. Vereinfacht lässt sich sagen: Je stärker die Verformung und je größer die Fläche der Verformung, desto stärker die Reaktionskraft auf das PhysX Objekt. Für die Flex Partikel des Flex Objekts heißt das: Je stärker die Partikel verschoben werden und je mehr Partikel verschoben werden, desto stärker ist die Reaktionskraft. Also müssen nur die Partikelverschiebungsvektoren ermittelt, umgedreht und summiert werden um einen finalen Kräftevektor zu erhalten, der sich wie gewünscht verhält. 
%Dabei werden die Partikelverschiebungsvektoren mit den Massen der verschobenen Partikel gewichtet. Dadurch werden schwerere FleX Objekte geringer verschoben.

Zusätzlich wird der Kräftevektor mit dem \textit{Stiffness} Parameter des Flex Objekts gewichtet.
Der Kräftevektor wird dann mithilfe eines einfachen Funktionsaufrufs an die PhysX Simulation übergeben. Danke des gegebenen PhysX Frameworks wirkt sich weiterhin auch die Masse des PhysX Objekts auf die Simulation aus: Je schwerer ein PhysX Objekt, desto stärker kann es Flex Objekte eindrücken.

\subsection{Kräfte und Momente}

Eine Funktionalität, die einige Game Engines anbieten, ist die Möglichkeit per Funktionsaufruf Kräftevektoren auf einzelne Körper wirken zu lassen. 
%Diese Funktionalität steht bei Game Engines als Funktion in der Form \textit{AddForce(FVector* ForceVector)} zur Verfügung, wie auch bei der Unreal Engine 4 (REEEEF). 

Diese Funktionalität wird meist genutzt um kräftebasierte Effekte oder Systeme zu programmieren. Beispielsweise können Kräfte auf Körper, die sich innerhalb einer Explosion befinden, angewandt werden, damit sie von der Explosion weg geschleudert werden. In REEEEEFFFF wird diese Funktionalität genutzt, um Auftriebskräfte auf schwimmende Objekte wirken zu lassen. 
Außerdem können mit dieser Funktionalität realistische Regelsysteme implementiert werden, die mit Kräften Körper balancieren oder zu einer Zielkonfiguration bewegen. In dieser Arbeit wird solch ein kräftebasiertes Regelsystem implementiert und dient als wichtige Grundlage für die Interaktion mit Soft Bodies in virtueller Realität ohne haptisches Feedback (siehe Kapitel \ref{sec_FSystem}).

Bei der verwendeten Unreal Engine mit Flex Integration gibt es nicht die Möglichkeit, Kräfte auf einzelne Flex-Objekte oder Flex-Partikel wirken zu lassen.

Die NVIDIA FleX Bibliothek bietet zwar die Möglichkeit an, Kraftfelder zu erstellen (\textit{NvFlexExtForceField}), allerdings gibt es nicht die Möglichkeit, Kräfte oder Momente gezielt auf einzelne Flex-Objekte oder Partikel wirken zu lassen. %Die Kräftefelder definieren nur einen Bereich, in dem konstante Kräftevektoren im Raum verteilt sind. Dann wirkt auf alle Partikel, die sich innerhalb eines Kräftefeldes befinden, eine Kraft, abhängig von den Partikelpositionen.

%Idee und Nasatz:
Eine einfache Möglichkeit die gewünschte Funktionalität zu ergänzen, ist die Manipulation der Partikelgeschwindigkeiten. Um eine Kraft, die auf ein Partikel wirken soll, zu simulieren, wird eine Geschwindigkeitsänderung, $\Delta\vec{v}$, zur aktuellen Geschwindigkeit, $\vec{v}$, des Partikels hinzu addiert. So kann die Flex-Simulation ungestört weiterlaufen und alle Constraints, wie das Kollisions-Constraint, wirken sich wie zuvor auf die simulierten Partikel aus.

%Methode
\subsubsection{Kräfte}
Gegeben sei eine Kraft, $\vec{F}$, die auf ein Flex-Objekt, das aus $n$ Partikeln besteht, wirken soll. Dann wird $\vec{F}$ in $n$ gleichgroße Partikelkräfte, $\vec{F_i} = \vec{F} / n$ unterteilt. Jede Partikelkraft, $\vec{F_i}$, wird dann auf ein Partikel, $i$, mit einer Punktmasse von $m_i$, angewandt.

Weil wir es mit Punktmassen zu tun haben, gilt für die Partikelkraft:

\begin{equation}
\vec{F_i} = m_i \cdot \vec{a} = m_i \dfrac{\Delta \vec{v_i}}{\Delta t}
\label{form_F}
\end{equation}

Also ergibt sich die Geschwindigkeit, $\Delta \vec{v_i}$, die zur Geschwindigkeit des Partikels addiert werden muss durch:

\begin{equation}
\Delta \vec{v_i} = \dfrac{\vec{F_i}}{m_i}\Delta t
\label{form_dv}
\end{equation}

Wobei $\Delta t$ der derzeitige Zeitschritt der Flex-Simulation ist. 

%Um eine Kraft auf ein komplettes Flex-Objekt zu wirken, wird $\Delta \vec{v_i}$ auf all seine Partikel angewandt. 
%Um die gesamte Kraft, die auf ein Flex-Objekt wirkt, zu berechnen, müssen alle Partikelkräfte, $F_i$ summiert werden.

Mit dieser einfachen Methode können Flex-Objekte realistisch umher geschoben werden. Wird eine Kraft von $(0 , 0 , 9.81 )$ Newton auf ein Flex-Objekts mit einer Masse von 1 kg angewandt, wirkt es schwerelos (bei $g=(0 , 0 , -9.81 )$). Das zeigt, dass alle Einheiten korrekt berechnet wurden.

%Die Masse eines Flex-Objekts ergibt sich durch die Summe all seiner $n$ Partikelmassen, beziehungsweise durch $n \cdot m_p$, wenn alle Partikelmassen, $m_p$, gleich groß sind.

\subsubsection{Momente}

Wirkt während eines Simulationsschritts ein Moment, $M$, auf ein Flex-Objekt, müssen auf all seine Partikel Winkelgeschwindigkeiten, $\Delta \omega_i$, hinzu addiert werden. Wie bei der Kraft auch, zerlegen wir $M$ in $n$ gleichgroße Partikelmomente, $M_i=M/n$ und betrachten nun kleinere Momente, die auf Punktmassen wirken.

%Zunächst wird die Winkelgeschwindigkeit, $\Delta \omega$, berechnet. 
Die Berechnung von $\Delta \omega_i$ erfolgt wie zuvor, nur im rotatorischem Sinne (Gleichung \ref{form_omega}):

\begin{equation}
\begin{split}
M_i = m_i   \dot{\omega}_i = m_i \dfrac{\Delta \omega_i}{\Delta t} \\
\Rightarrow  \Delta \omega_i = \dfrac{M_i}{m_i} \Delta t
\end{split}
\label{form_omega}
\end{equation}

Um die Rechenkomplexität zu senken, gehen wir davon aus, dass alle Partikel die selbe Masse haben, wodurch alle Partikel um die selbe Winkelgeschwindigkeit ($\Delta \omega_i$) rotiert werden müssen. 

Neben der Größe des Moments, $M_i$, sei auch eine örtlich gebundene Achse definiert, die angibt in welche Richtung das Drehmoment wirkt. Diese Achse besteht aus einem normalisierten Richtungsvektor, $\vec{e}$, der sich an der Position, $\vec{c}$, befindet (siehe Abbildung \ref{moment}). $\vec{e}$ und $\vec{c}$ definieren also die örtlich gebundene Achse, um die sich das Flex-Objekt drehen wird, aufgrund des wirkenden Drehmoments. Das bedeutet, alle $n$ Partikel sollen sich nun zusätzlich mit einer Winkelgeschwindigkeit von $\Delta \omega_i$ um diese Drehmomentachse drehen.

Nun muss berechnet werden, in welche vektorielle Richtung, $\Delta \vec{v_i}$ sich ein Partikel $i$ bewegen muss, damit es sich mit der gewünschten Winkelgeschwindigkeit, $\Delta \omega_i$, um die Drehmomentachse dreht. Dabei habe das Partikel die Position $\vec{p_i}$. Abbildung \ref{moment} visualisiert diese Problemstellung.

\bild{moment}{5cm}{Das Partikel $i$ muss sich zusätzlich in die Richtung $\vec{d}$ bewegen, damit es damit beginnt, sich um die Drehmomentachse zu drehen. Die Drehmomentachse habe die Position $\vec{c}$ und Ausrichtung $\vec{e}$}


$\Delta \vec{v_i}$ besteht aus einer Geschwindigkeit, $s=|\Delta \vec{v_i}|$ und einer Bewegungsrichtung, $\vec{d}$, mit $|\vec{d}|=1$. Das heißt es gilt $\Delta \vec{v_i} = s \cdot \vec{d}$.

$s$ ist die Umfangsgeschwindigkeit des Partikels, um die Drehmomentachse und ist abhängig von der Winkelgeschwindigkeit $\Delta \omega_i$ (siehe Gleichung \ref{form_speed}).

\begin{equation}
s = \Delta \omega_i \cdot r
\label{form_speed}
\end{equation}

$r$ ist dabei die kürzeste Entfernung, die das Partikel zur Drehmomentachse hat.
Weil $|\vec{e}|=1$, kann $r$ aus dem folgenden Skalarprodukt berechnet werden (siehe Gleichung \ref{form_r}):

\begin{equation}
r = ||\vec{e} \cdot \vec{u_i}||
\label{form_r}
\end{equation}

-Mit $\vec{u_i}=\vec{p_i}-\vec{c}$. 

Der Richtungsvektor, $\vec{d}$, muss orthogonal zu $\vec{u_i}$ und $\vec{e}$ sein und eine Länge von 1 haben. Also kann $\vec{d}$ mit Gleich \ref{form_dir} berechnet werden:

\begin{equation}
\vec{d} = unit(\vec{u_i} \times \vec{e} )
\label{form_dir}
\end{equation}

Wobei mit $unit(...)$ der Einheitsvektor aus dem Kreuzprodukt $\vec{u_i} \times \vec{e} $ gemeint ist.

Schlussendlich ergibt sich die Geschwindigkeit, die zur Partikelgeschiwindigkeit hinzu addiert werden muss durch (Gleichung \ref{form_momentfinal}):

\begin{equation}
\Delta \vec{v_i} =  \dfrac{M_i}{m_i} \Delta t ||\vec{e} \cdot \vec{u}|| \cdot unit(\vec{u_i} \times \vec{e} )
\label{form_momentfinal}
\end{equation}

TODO: Kurz erläutern wie das funktioniert und was Probleme sind (Partikel wollen sich immer bisl weg von Achse bewegen, wodurch innere Spannungen auftreten, die con constraints aber gelöst werden...

%\section{ALT}

%-------------------------------------- ALT -----------------------------------------------
%In Kapitel \ref{chap_Theorie} wird es darum gehen, Reynolds Boid-Simulationsmodell so anzupassen, dass alle für die Simulation nötigen Arbeitsschritte möglichst effizient von Shadern ausgeführt werden können.
%
%Wegen der besonderen Funktionsweise von Shadern können manche Arbeitsschritte aus Reynolds Simulationsmodell nicht auf direktem Wege übernommen und implementiert werden. Daher werden manche Gesetzmäßigkeiten aus dem gegebenen Modell uminterpretiert und umformuliert. Bei Umformulierungen wird stets darauf geachtet, die grundlegenden Prinzipien des Boid-Systems möglichst unverändert zu lassen, da sich das dieses System bereits in der Praxis bewährt hat.
%
%Wie bereits erwähnt, ist \ac{CDMR} die technische Grundlage für die Implementierung des Boid-Systems. 
%Wesentliches Funktionsprinzip von \ac{CDMR} ist die Bildung einer Shader-Pipeline, die Texturen verarbeitet. Also muss das Boid-System so uminterpretiert werden, dass dieses möglichst effizient von Texturen beschrieben und von Shadern simuliert werden kann.
%
%
%\section{Das Boid-System als Zellensystem}
%\label{sec_noParticelCells}
%
%In diesem Kapitel wird ein wichtiger Grundsatz festgelegt, der das Fundament des uminterpretierten Boid-Systems bildet.
%
%Das Boid-System ist mit dem Partikelsystem verwand \cite{Reynolds87flocks} und kann daher für gewöhnlich auch als solches behandelt werden.
%
%Weil in diesem Fall das Boid-System von Texturen beschrieben wird, muss also ein partikelähnliches System von Pixel-Shadern beschrieben werden. Herkömmliche Shader sind allerdings schlecht für die Beschreibung von Partikelsystemen geeignet. Das liegt an der folgenden Problematik:
% 
%Wesentlicher Bestandteil eines Partikelsystems ist die Bewegung, also die Positionsänderung, von Partikeln. 
%Ein Shader kann ein Pixel allerdings nicht ohne weiteres bewegen. Das hängt damit zusammen, dass ein Pixel-Thread nicht in der Lage ist, Werte in andere Pixel zu schreiben. Jedes Pixel kann sein Rechenergebnis nur in sich selbst hinein schreiben (Siehe Kapitel \ref{subsec_ScatterVSGather}).
%
%Jedes Pixel als einzelnes Partikel zu betrachten, ist daher nicht empfehlenswert. Ein Partikel, beschrieben von einem Pixel, könnte dann nämlich nicht ohne weiteres seine Position ändern und könnte sich somit schlecht bewegen.
%
%Statt nun über Umwege zu versuchen ein Partikelsystem mit Texturen zu beschreiben, verabschieden wir uns an dieser Stelle vom Gedanken des Partikelsystems. Stattdessen wird das Boidsystem von einem Zellen-System beschrieben, wie bei shaderbasierten Flüssigkeitsströmungssimulationen \cite{GPUGems1} auch. 
%
%Das bedeutet, dass verwendete Texturen kein Partikelsystem, sondern ein Zellensystem repräsentieren. Ein Pixel aus einer Textur beschreibt kein umherfliegendes Boid, sondern eine Zelle, die eine Menge von Boids enthalten kann. Die Individuen des Schwarms bewegen sich dabei durch nebeneinanderliegende Zellen hindurch.
%
%Weil sich hinter jeder Zelle ein Pixel-Thread verbirgt, sind es im Grunde die Zellen, die die umherfliegenden Boids  \glqq steuern\grqq{}. Jede Zelle kann unterschiedlich viele Boids besitzen und berechnet Steuersignale für ihre Boids.
%
%
%
%\section{Texturen zur Beschreibung des Boid-Systems}
%
%Um die Zustände aller vorhandenen Boids genau zu kennen, werden lediglich zwei Größen benötigt. Zum ersten wird die Information benötigt, wo  im Raum sich Boids befinden. Zweitens benötigt jedes Boid einen Steuervektor (Siehe Kapitel \ref{section_Reynold}). 
%
%Im einfachem Fall resultieren aus diesen beiden Größen zwei Texturen. Falls möglich, können beide Texturen auch in eine Textur zusammengefasst werden um Ressourcen zu sparen. In dieser Arbeit wurden zwei Texturen eingesetzt um die Übersichtlichkeit zu verbessern.
%
%Ein Shader kann nicht dieselbe Textur beschreiben, die er zugleich einliest. Deswegen wird meist eine zweite zwischengespeicherte Kopie einer Textur benötigt.
%
%
%
%\subsection{Boid-Dichte-Textur, \emph{D}}
%
%Diese Textur ist ein Maß für die Dichte des Schwarms. Es handelt sich hierbei um ein Skalarfeld, das beschreibt, wie viele Boids wo im Raum sind. Die Koordinate eines Pixels entspricht einem Ort im Raum. Der Wert eines Pixels gibt die Menge der Boids an. Je größer der Wert, desto mehr Boids halten sich in der Zelle auf und desto höher ist hier die  \glqq \textit{Boid-Dichte}\grqq{}. Der Wert eines Pixels ist dabei eine Fließkommazahl, das heißt es können sich beispielsweise auch 1,5 Boids in einer Zelle aufhalten. 
%
%\bild{D}{6cm}{Ein zweidimensionaler Schwarm, beschrieben von der \textit{Boid-Density-Texture}, $D$.}
%
%In Abbildung \ref{D} wird eine zweidimensionale Boid-Textur abgebildet. Helle Stellen weisen eine höhere Boid-Dichte auf als dunklere Stellen. In der Unreal Engine 4 können Texturen auch negative Werte enthalten. Bei der Boid-Textur werden aber keine negativen Werte erlaubt. Eine Zelle kann keine negative Menge Boids enthalten.
%
%\clearpage
%\subsection{Steuervektoren-Textur, $\vec{V}$}
%
%Die $\vec{V}$-Textur ist farbig und repräsentiert daher ein Vektorfeld oder einen Vektorraum, im dreidimensionalem Falle. Abbildung \ref{V} zeigt ein zweidimensionales Beispiel von $\vec{V}$.
%
%\bild{V}{6cm}{Ein Beispielbild der Steuervektoren-Textur, $\vec{V}$}
%
%Jeder Vektor, bzw. jeder Farbwert aus dieser Textur ist die gewichtete Summe aus allen Steuervektoren, $\vec{v_i}$, die eine Zelle generiert hat.
%
%In vielen Videospiele-Engines können sogenannte  \glqq High Dynamic Range\grqq{}-Texturen reserviert werden. Solche Texturen können auch negative Werte und Werte über 1 verwenden. Die Steuervektoren-Textur sollte solch eine Textur sein, damit ihre Vektoren auch in negative Richtungen zeigen können.
%
%
%
%\section{Aufbau der Shader-Pipeline}
%\label{sec_ShaderUebersichttheorie}
%
%Das gegebene Simulationsmodell von Reynolds kann in wenige Arbeitsschritte unterteilt werden. Aus jedem Arbeitsschritt resultiert ein Shader. Alle Shader werden dann zu einer Shader-Pipeline verknüpft. Die Shader-Pipeline führt Schritt für Schritt alle nötigen Arbeitsschritte der Schwarmsimulation aus. 
%\clearpage
%\bild{SoftwareUeberblick}{14cm}{Ein Beispiel wie die Shader-Pipeline aussehen könnte. Alle als Kreis dargestellten Shader werden der Reihe nach von links nach rechts ausgeführt. Die Pfeilrichtungen zeigen eine lese/schreib-Beziehung an. Die Pipeline lässt sich mit beliebig vielen Shadern, $S_i$, erweitern, auch zur Laufzeit der Simulation.}
%
%Abbildung \ref{SoftwareUeberblick} stellt die Shader-Pipeline dar, die die Schwarmsimulation ausführt. 
%Alle Kreise repräsentieren Shader-Programme. Jedes Rechteck ist eine Textur. Die Pfeile geben an, ob ein Shader eine Textur einliest oder beschreibt. 
%%Wenn in Abbildung \ref{SoftwareUeberblick} eine Textur vom selben Shader sowohl gelesen als auch beschrieben wird, geschieht dies mithilfe einer Zwischenkopie.
%
%Pro Simulationsschritt werden in Abbildung \ref{SoftwareUeberblick} von links nach rechts der Reihe nach alle Shader ausgeführt.
%
%\subsubsection{SReynoldsRules}
%
%Zuerst wird laut Abbildung \ref{SoftwareUeberblick} ein Shader namens \textit{SReynoldsRules} ausgeführt. Er berechnet Steuervektoren, $\vec{V}$, der Boids, durch Anwendung  der drei Grundverhaltensregeln von Reynolds. Die berechneten Steuersignale werden in die \textit{Control-Vector}-Textur abgelegt. Für die ersten beiden Verhaltensregeln Kohäsion, $c$, und Separation, $s$, wird die Boid-Dichte, $D$,  benötigt. Deswegen liest \textit{SReynoldsRules} die \textit{Boid-Density}-Textur ein. Um die letzte Grundverhaltensregel, Ausrichtung, $a$, anzuwenden, muss zusätzlich die derzeitige Bewegungsrichtung, $\vec{V}$, der Boids eingelesen werden. Die drei Grundverhaltensregeln werden mit den Parametern $w_c$, $w_s$ und $w_a$ gewichtet. Die dabei entstehenden drei Produkte werden daraufhin summiert, so wie in Formel \ref{GewSummeV} zu sehen:
%
%\begin{equation}
%\vec{V_{SReynoldsRules}} = w_c \cdot \vec{v_c} + w_s \cdot \vec{v_s} + w_a \cdot \vec{v_a}
%\label{GewSummeV}
%\end{equation}
%
%\subsubsection{Zusatzverhaltensregel-Shader}
%
%Danach können die zuvor berechneten Steuervektoren, $\vec{V}$, von beliebig vielen weiteren Shadern, $S_{1,2, ...,N}$, weiterverarbeitet werden um Zusatzverhaltensregeln anzuwenden. Jeder Shader, $S_i$, repräsentiert eine Zusatzverhaltensregel. Jedes $S_i$ berechnet  weitere Steuersignale, $\vec{v_i}$ und addiert diese zu $\vec{V}$ hinzu. Auch hier wird mit Gewichten, $w_i$, gearbeitet. Somit entwickelt sich die Steuervektoren-Textur, $\vec{V}$, weiter nach Gleichung \ref{GewSummeV}:
%
%\begin{equation}
%\vec{V} = \vec{V_{SReynoldsRules}} + \sum_{i=1}^N(w_i \cdot \vec{v_i})
%\label{GewSummeV}
%\end{equation}
%
%Nachdem alle Shader, $S_{1,2, ...,N}$, passiert wurden, ist die Steuervektoren-Textur, $\vec{V}$, vollständig generiert worden und ist bereit für die Übergabe in den Shader \textit{SBoidTransport}.
%
%
%\subsubsection{SBoidTransport}
%Zuletzt wird $\vec{V}$ einem Shader namens \textit{SBoidTransport} übergeben um die Boid-Textur, $D$, mithilfe der Steuervektoren zu bewegen. Die Bewegung der Boids ist nicht ganz einfach. Das liegt vor allem daran, dass hierfür eine Gather-Methodik eingesetzt werden sollte. Deswegen wurde für diesen Shader ein Extra Kapitel angelegt (Kapitel \ref{section_BewDerBoids}).
%
%
%\subsection{Flexibilität der Shader-Pipeline}
%\label{subsec_kombinationsmoeglichkeitdershader}
%
%Die in Abbildung \ref{SoftwareUeberblick} vorgeschlagene Shader-Pipeline kann auch beliebig umgeformt werden, solange dabei das vorgegebene Grundprinzip nicht verändert wird. So könnte beispielsweise der Shader \textit{SReynoldsRules} in drei einzelne Shader unterteilt werden, wenn eine bessere Übersicht und Flexibilität erwünscht ist. Es können auch mehrere Shader in ein einziges Shader-Programm zusammengefasst werden. Es muss nur dafür gesorgt werden, dass die Shader-Pipeline alle in diesem Kapitel gezeigten Arbeitsschritte umsetzt.
%
%
%
%
%
%
%\section{Generierung der Einzelsteuersignale}
%\label{sec_ShaderGrundverhaltensregeln}
%Die erste große Aufgabe der Simulations-Shader-Pipleine ist die Generierung der Einzelsteuersignale, $\vec{v}_c$, $\vec{v}_s$, $\vec{v}_a$, $\vec{v}_{cp}$ und  $\vec{v}_{sp}$. Kapitel \ref{sec_ShaderGrundverhaltensregeln} befasst sich mit dieser Aufgabenstellung.
%
%Die in Kapitel \ref{sec_ShaderGrundverhaltensregeln} angestellten Überlegungen beziehen sich stets auf ein Boid-System, das im zweidimensionalen Raum agiert. Die hierbei entstehenden Prinzipien und Formeln lassen sich ohne großen Mehraufwand in die dritte Dimension transferieren. Das Boid-System muss dann von dreidimensionalen Texturen beschrieben werden. Um die Dinge einfach zu halten, arbeiten wir aber vorerst im zweidimensionalen Raum und nutzen stets zweidimensionale Texturen und Zellensysteme.
%
%\subsection{Nachbarsuche mit Wahrnehmungsvektoren}
%\label{subsec_nachbarsucheMitTestvektoren}
%
%
%Laut Reynolds hat ein Boid die grundlegende Fähigkeit, Informationen über benachbarte Boids abfragen zu können. Daher muss eine effiziente Nachbarsuche konzipiert werden. Die Nachbarsuche kann mithilfe von sogenannten Wahrnehmungsvektoren, $\vec{s}$ erfolgen.
%
%%Ein Vorteil bei der Nutzung von Texturen zur Beschreibung des Boid-Systems als Zellen-System ist der, das die Position eines Pixel auch einem Ort im Raum entspricht. Daher muss ein Pixel, bzw. eine Zelle nur benachbarte Zellen auslesen um Informationen über die Nachbarschaft zu erhalten. Dafür können benachbarte Zellen auch zeitweise keine wertvolle Information enthalten und leer sein, was als ineffiziente Speichernutzung interpretiert werden kann. Ein Großteil des GPU-Speichers wird sozusagen für die Beschreibung von leeren Raum genutzt. Prinzipiell wird hier also Rechenaufwand reduziert, aber gegen eine höhere Ressourcenreservierung eingetauscht.
%
%Gegeben sei eine zweidimensionale Textur mit einer Auflösung von $R$ mal $R$ Pixeln. Dann ist die Entfernung zwischen zwei Pixeln $1/R$ (siehe Kapitel \ref{subsec_BilFiltUV}). Die Nachbarsuche erfolgt mithilfe von $N$ Wahrnehmungsvektoren. Dabei soll ein Wahrnehmungsvektor, der eine Länge von $1$ hat, eine Entfernung von $1/R$ im UV-Koordinatensystem zurücklegen. Er ist dann also genau so lang wie eine Zelle groß ist. 
%
%Wie mit einem Wahrnehmungsvektor, $\vec{s}$, auf eine benachbarte UV-Koordinate, $x_s$, zugegriffen wird, zeigt Abbildung \ref{UV_T}.
%
%\bild{UV_T}{5cm}{Das rot hervorgehobene Quadrat sei eine aktive Zelle. Sie befindet sich bei $x$ und besitzt einen Wahrnehmungsvektor $s$ (rot), mit dem sie auf eine Nachbarzellen zugreifen kann. In diesem Fall greift sie auf ihren oberen rechten Nachbar zu. Also ist hier $s=(1  \quad -1)$.}
%
%Eine Zelle, die sich an der Stelle $x$ befindet, berechnet den Ort eines Nachbars, $x_s$, mithilfe eines Wahrnehmungsvektors, $\vec{s}$, nach Formel \ref{Form_UVT}: 
%
%\begin{equation}
%x_s = x + \vec{s} \cdot \dfrac{1}{R}
%\label{Form_UVT}
%\end{equation}
%
%Mit diesem Grundprinzip kann der Zugriff auf Nachbarzellen besonders flexibel und vielfältig gestaltet werden. Abbildung \ref{Abb_TestVecsBsp} zeigt einige Vorschläge, wie Wahrnehmungsvektoren eingesetzt werden könnten.
%
%\bild{Abb_TestVecsBsp}{10cm}{Eineige Beispiele wie eine aktive Zelle, bzw. ein Boid, mit Wahrnehmungsvektoren ausgerüstet werden kann. Wahrnehmungsvektoren können auch direkt in die Mitte von 4 Zellen zeigen. So wie es im mittlerem Bild getan wird.}
%
%Wie Abbildung \ref{Abb_TestVecsBsp} zeigt, können beliebig viele Wahrnehmungsvektoren eingesetzt werden und es kann mit unterschiedlichen Vektororientierungen, Anordnungen und Vektorlängen gearbeitet werden. All diese Variierungsmöglichkeiten bieten Raum für Kreativität. Hierzu folgen einige Überlegungen: 
%
%\newcommand{\length}[1]{\lvert \vec{#1} \rvert}%%%%%%%%%%%%%%%%%%%%%%LENGTH
%
%Jeder Wahrnehmungsvektor kann im übertragendem Sinne wie ein \textit{Wahrnehmungssensor} verstanden werden, der mit einer  \glqq Stange\grqq{} an einem Boid befestigt wird. Die Länge einer solchen Stange entspricht dabei $\length{s}$. Mit der Länge kann dann festgelegt werden \glqq wie weit\grqq{} ein Boid \glqq sehen\grqq{} kann. Beim Einsatz von wenigen Wahrnehmungsvektoren wird der Rechenaufwand zwar reduziert, dafür besitzt ein Boid dann eine geringe  \glqq Wahrnehmungsdichte\grqq{} und könnte daher manche Nachbarn  \glqq übersehen\grqq{}.
%
%Eine Besonderheit ist auch die Möglichkeit, Wahrnehmungsvektoren genau auf die Stelle zwischen 4 benachbarten Pixeln zeigen zu lassen. Hierbei kann von der bilinearen Filterung profitiert werden (Siehe Kapitel \ref{subsec_BilFiltUV}). Die meisten modernen Grafikkarten implementieren die bilineare Filterung auf Hardwareebene \cite{BilTexFilt}. Der dabei berechnete gewichtete Mittelwert stellt dadurch also fast keinen Mehraufwand für die \ac{GPU} dar. So können Informationen über 4 Zellen in Erfahrung gebracht werden, mit nur einer Abfrage.
%
%Eine weitere Möglichkeit wäre die Wahrnehmungsvektoren mit der Zeit variieren zu lassen. Wahrnehmungsvektoren könnten beispielsweise langsam um ein Boid herum rotieren. Wahrnehmungslücken, die bei der Verwendung von wenigen Wahrnehmungsvektoren entstehen, könnten so im Verlauf der Zeit gefüllt werden. Während eines einzelnen Zeitschritts existieren  dann zwar immer noch Wahrnehmungslücken, aber bei Betrachtung mehrerer Zeitschritte werden genügend Nachbarschaftsabfragen vorgenommen. Die Boids nutzen dann im übertragendem Sinne einen rotierenden Laserscanner, um ihre Umgebung abzutasten, so wie in der Robotik üblich.
%
%\subsection{Kohäsion}
%
%Das Steuersignal, das aus der Verhaltensregeln der Kohäsion resultiert, wird $\vec{v}_c$ genannt, wobei $c$ für Cohesion steht. $\vec{v}_c$ ist vereinfacht gesagt ein Vektor, der zum Schwerpunkt aller gefundenen Nachbarn zeigt. 
%Jede Zelle ist ein eigener Thread und berechnet ihr eigenes Kohäsions-Steuersignal, $\vec{v}_c$.
%Um $\vec{v}_c$ zu berechnen, wird die Boid-Dichte-Textur, $D$, benötigt. $D$ gibt an, wie viele Boids in einer Zelle vorhanden sind.
%
%Gegeben sei eine Zelle, $X$, die sich am Ort $x = (x_u \qquad x_v)$ befindet. Diese Zelle berechnet ein Kohäsions-Steuersignal für diesen Ort, $\vec{v}_c(x)$, mithilfe von $N$ gegebenen Wahrnehmungsvektoren. Mit einem Wahrnehmungsvektor, $\vec{s}_i$, kann eine Stichprobe, $D_i$, aus $D$ genommen werden.
%
%\begin{equation}
%D_i(x) = D(x + \vec{s}_i \cdot \dfrac{1}{R})
%\label{Form_Di}
%\end{equation}
%
%In Abbildung \ref{ChesionAbb} wird Zelle $X$ dargestellt, wobei in diesem Beispiel $N=4$ Wahrnehmungsvektoren gegeben sind.
%
%\bild{ChesionAbb}{5cm}{Die rot markierte Zelle heißt $X$ und befindet sich an Position $x$. Sie besitzt 4 Wahrnehmungsvektoren, $\vec{s}_i$. Mit ihnen ist die Zelle in der Lage Stichproben, $D_i$, aus der Boid-Textur, $D$, zu entnehmen.}
%
%Mithilfe der Stichproben, $D_i$, wird dann das Kohäsions-Steuersignal, $\vec{v}_c$, wie folgt berechnet:
%
%\begin{equation}
%\vec{v}_c(x) = \dfrac{\sum_{i=1}^N( \vec{s}_i \cdot D_i(x))}{\sum_{i=1}^N D_i(x)}
%\label{Form_Cohesion}
%\end{equation}
%
%Es folgt nun Schrittweise eine Erklärung, inwiefern Formel \ref{Form_Cohesion} mit Reynolds Kohäsions-Gesetz zusammenhängt. Begonnen wird mit dem Zähler, indem jeder Wahrnehmungsvektor, $\vec{s}_i$ mit seiner Stichprobe, $D_i$, multipliziert wird. Hier wird im Grunde nichts geringeres getan, als Vektoren von der Zelle $X$ zu allen gefundenen Nachbarn zu spannen.
%
%Ist beispielsweise die Stichprobe $D_1$ aus Abbildung \ref{ChesionAbb} gleich 2, bedeutet dies, dass sich in der Zelle an der Stelle $x + \vec{s}_1$ zwei Boids befinden. Das Produkt aus $D_1$ und $\vec{s}_1$ ergibt $2 \dot \vec{s}_1$. Somit werden zwei Vektoren zu einer Zelle gespannt, die zwei Boids aufbewahrt. Im Umkehrschluss Würden keine Vektoren nach $x + \vec{s}_1$ gespannt werden, wenn $D_1 = 0$ wäre, weil dann $D_1 \cdot \vec{s}_1 = 0$ ist.
%
%Zum Schluss wird der Mittelwert aus allen gespannten Vektoren gebildet, indem durch die Anzahl aller gefundenen Nachbarn, $\sum_{i=1}^N D_i$, geteilt wird. 
%
%Mit Formel \ref{Form_Cohesion} wird $\vec{v}_c$ prinzipiell so wie Reynolds es in \cite{Reynolds99steeringbehaviors} vorschlägt, berechnet. Statt den Schwerpunkt der Nachbarn zu berechnen und dann einen Vektor von $x$ zum Schwerpunkt zu ziehen, kann auch der Durchschnitt aus allen zu den Nachbarn zeigenden Vektoren gebildet werden. Genau das wird hier getan. 
%
%
%\subsection{Separation}
%
%Auch hier gilt wieder, das jeder Wahrnehmungsvektor, $\vec{s}_i$, eine Stichprobe, $D_i$, aus $D$ liefert, die ein Maß für die Anzahl der gefundenen Boids ist (Siehe Gleichung \ref{Form_Di}). Zudem wird wieder eine Zelle namens $X$, die sich bei Position $x$ befindet, betrachtet.
%
%Das Separations-Steuersignal, $\vec{v}_s$, arbeitet im Gegensatz zur Kohäsion mit Vektoren, die von den entdeckten Nachbarn weg und zum gesteuerten Boid hin zeigen. Die Größe des Steuervektors, $\vec{v}_s$, steigt umso mehr an, je näher ein Nachbar ist. Reynolds empfiehlt hierfür mit umgekehrter Proportionalität zu arbeiten \cite{Reynolds99steeringbehaviors}.
%So entsteht schlussendlich Formel \ref{Form_Separation}:
%
%\begin{equation}
%\vec{v}_s(x) = \sum_{i=1}^N (-D_i(x) \cdot e(\vec{s}_i) \cdot \dfrac{1}{\length{s_i}}) = - \sum_{i=1}^N(D_i(x) \cdot \dfrac{\vec{s}_i}{\length{s_i}^2})
%\label{Form_Separation}
%\end{equation}
%
%Auch hier werden zuerst Vektoren zu allen Nachbarn gespannt, indem das Produkt aus $D_i$ und $\vec{s}_i$ gebildet wird. Weil in diesem Fall die Größe der gespannten Vektoren aber noch gesondert behandelt werden muss, werden sie vorerst normiert. So ergibt sich $D_i \cdot e(\vec{s}_i)$. Wenn beispielsweise $D_i = 2$ ist, werden zwei Einheitsvektoren erzeugt, die von $x$ in die Richtung der beiden Nachbarn zeigen. Natürlich werden alle Einheitsvektoren noch umgedreht, damit abstoßende Kräfte entstehen. All diese abstoßenden Einheitsvektoren werden dann mit $1/ \length{s_i}$ gewichtet, so wie von Reynolds in \cite{Reynolds99steeringbehaviors} empfohlen. Je kürzer $\vec{s}_i$ ist, desto größer wird die abstoßende Kraft sein. Zuletzt werden alle Vektoren summiert und es entsteht das fertige Separations-Steuersignal, $\vec{v}_s$.
%
%
%
%\subsection{Ausrichtung}
%\label{subsec_Ausrichtung}
%
%Das Steuersignal, $\vec{v}_a$, soll dafür sorgen, dass sich ein Boid der Bewegungsrichtung und Geschwindigkeit seiner Nachbarschaft anpasst. Diesmal ist also nicht nur die Menge und Position der Boids von Interesse, sondern auch deren aktuellen Steuervektoren, $\vec{V}$. Die Steuervektoren geben nämlich an, in welche Richtungen sich die Boids gerade bewegen. Für die Berechnung von $\vec{v}_a$ muss nicht nur $D$, sondern auch die Steuervektoren-Textur, $\vec{V}$, untersucht werden.
%
%Die Nachbarschaftssuche um Position $x$ herum, wird wieder mithilfe von $N$ Wahrnehmungsvektoren unternommen. Jeder Wahrnehmungsvektor, $\vec{s}_i$, wird dabei eine Stichprobe, $\vec{V}_i(x)$, aus der Textur, $\vec{V}$, entnehmen. Die Berechnung von $\vec{V}_i(x)$ erfolgt nach Formel \ref{Form_Vi}:
%
%\begin{equation}
%\vec{V}_i(x) = \vec{V}(x + \vec{s}_i \cdot \dfrac{1}{R})
%\label{Form_Vi}
%\end{equation}
%
%Wobei $R$ die Auflösung von $\vec{V}$ ist. Hierbei ist zu beachten, dass $\vec{V}$ einen Steuervektor von einer Zelle liefert. In einer Zelle können sich mehrere Boids aufhalten. Das Bedeutet, dass $\vec{V}$ einen Steuervektor von mehreren Boids liefern kann. Dies wird bei der Berechnung von $\vec{v}_a$, in Formel \ref{Form_Align}, berücksichtigt.
%
%\begin{equation}
%\vec{v}_a(x) = \dfrac{\sum_{i=1}^N(\vec{V}_i(x) \cdot D_i(x))}{\sum_{i=1}^N(D_i(x))} - \vec{V}(x)
%\label{Form_Align}
%\end{equation}
%
%Zuerst wird im Zähler des ersten Terms die Summe aller Steuervektoren aus der Nachbarschaft gebildet. Die Summe aller Steuervektoren, aus einer benachbarten Zelle, kann mit $\vec{V}_i \cdot D_i$ errechnet werden. Befinden sich beispielsweise zwei Boids in der durchsuchten Zelle, ist $D_i=2$. Dann müsste also das Steuersignal auch doppelt genommen werden um die Summe aller Steuersignale zu erhalten. Daher wird hier mit $\vec{V}_i \cdot D_i$ gearbeitet. Nachdem die Summe aller Steuervektoren gebildet wurde, wird diese durch die Anzahl an gefundenen Steuersignalen geteilt. Die Anzahl der gefundenen Steuersignale entspricht der Anzahl der gefundenen Boids, $\sum_{i=1}^N(D_i(x))$.
%
%Nachdem die durchschnittliche Bewegungsrichtung der Nachbarschaft ermittelt wurde, wird davon die eigene Bewegungsrichtung, $\vec{V}(x)$, abgezogen, so wie es auch in \cite{Reynolds99steeringbehaviors} getan wird. 
%
%Formel \ref{Form_Align} kann auch zu Formel \ref{Form_AlignCa} vereinfacht werden. Bei dieser Vereinfachung wird ein Steuersignal aus einer Zelle, $\vec{V}_i$, direkt als Durchschnittssignal interpretiert.
%
%\begin{equation}
%\vec{v}_a(x)  \approx \dfrac{\sum_{i=1}^N(\vec{V}_i(x))}{N_V} - \vec{V}(x)
%\label{Form_AlignCa}
%\end{equation}
%
%Formel \ref{Form_AlignCa} unterscheidet sich von Gleichung \ref{Form_Align} in der Berechnung der durchschnittlichen Bewegungsrichtung. Hierfür werden alle Stichproben, $\vec{V}_i$, summiert und dann durch die Anzahl aller erfolgreichen Stichproben, $N_V$, geteilt.
%
%Formel \ref{Form_Align} berücksichtigt im Gegensatz zu Formel \ref{Form_AlignCa} wie voll eine durchsuchte Nachbarzelle ist. In Gleichung \ref{Form_Align} werden nämlich bei der Bildung des Mittelwertes Zellen, die mehr Boids enthalten, stärker gewichtet. Formel \ref{Form_AlignCa} hingegen gewichtet alle Stichproben gleich stark.
%
%
%\subsection{Zusatzverhaltensregeln}
%
%Wie bereits erwähnt, können für die Simulation beliebige Zusatzverhaltensregeln erfunden und angewandt werden. Im Rahmen dieser Bachelorarbeit wurden zwei verhältnismäßig einfache Zusatzverhaltensregeln eingesetzt. Zweck beider Regeln ist vor allem der, mit dem in Echtzeit agierenden Schwarm interagieren zu können.
%
%\subsubsection{Position verfolgen}
%
%Diese Regel generiert ein weiteres Einzelsteuersignal namens $\vec{v}_{cp}$. Hierfür wird ein  \glqq Kohäsionspunkt\grqq{} im Raum definiert. Ein Kohäsionspunkt, $P_{Coh}$, ist ein Punkt, der Boids anzieht. Je weiter ein Boid von $P_{Coh}$ entfernt ist, desto stärker wirkt die Anziehung auf das Individuum.
%
%\clearpage
%\bild{v_cp}{6cm}{Die Boids, die sich in Zelle $X$, bei Position $x$ befinden werden vom Kohäsionspunkt, $P_{Coh}$, angezogen. Ein zum Punkt zeigendes Steuersignal, $\vec{v}_{cp}$, entsteht.}
%
%Wie Abbildung \ref{v_cp} zeigt, ist das Steuersignal $\vec{v}_{cp}$ ein Vektor, der von Position $x$ zum Kohäsionspunkt $P_{Coh}$ gespannt wird. Somit ergibt sich Formel \ref{Form_v_cp}:
%
%\begin{equation}
%\vec{v}_{cp}(x) = P_{Coh} - x
%\label{Form_v_cp}
%\end{equation}
%
%Der Kohäsionspunkt lässt sich auch zur Simulationslaufzeit versetzen. So kann der Nutzer der Software den Schwarm in beliebige Richtungen \glqq dirigieren\grqq{}.
%
%
%\subsubsection{Position meiden}
%\textit{Position meiden} ist das Gegenstück zur Verhaltensregel \textit{Position verfolgen}. Hier wird ein Separationspunkt, $P_{Sep}$, definiert, der von einem Boid stets gemieden werden soll. Es wird zuerst ein Vektor vom Separationspunkt weg und zum betrachtetem Boid, $X$, hinüber gespannt. Die Größe des abstoßenden Vektors soll hierbei umso größer sein, je näher sich ein Boid am Separationspunkt befindet. Dies geschieht wie in Formel \ref{Form_v_sp} gezeigt:
%
%\begin{equation}
%\vec{v}_{sp}(x) = \vec{e}(x-P_{Sep}) \cdot \dfrac{1}{\length{x-P_{Sep}}}
%\label{Form_v_sp}
%\end{equation}
%
%Der Einheitsvektor von $x-P_{Sep}$ wird hierfür umgekehrt proportional zu seiner Länge gewichtet.
%
%Der Spieler der Software kann dank dieser Verhaltensregel einen Schwarm jagen und Gruppenteilungen erzwingen.
%
%
%
%
%\section{Verhaltensänderungen des Schwarms}
%\label{subsec_Verhaltensaenderungen}
%Durch gezielte Parametrisierung der Gewichtungen für die Grundverhaltensregeln kann das Verhalten des Schwarms gezielt verändert werden. Wenn zur Simulationslaufzeit beispielsweise ein Jäger erscheint, könnte das Verhalten des Schwarms, entsprechend der neuen Situation, verändert werden. Bei geschicktem Einsatz kann der Schwarm so noch lebendiger und echter wirken.
%
%Es folgen hierfür einige Beispiele.
%
%\subsection{Zusammenrottungsverhalten steigern/schwächen}
%
%Die Sorge den Anschluss zum Schwarm zu verlieren, ist in einer lebensbedrohlichen Situation eventuell größer als zuvor. Dadurch könnte eine stärkere Zusammenrottung entstehen. Ein stärkeres Zusammenrottungsverhalten kann generiert werden indem die Separation geschwächt und die Kohäsion verstärkt werden \\ \cite{Oliver14Tschesche}.
%
%\subsection{Konkurrenzverhalten steigern/senken}
%
%Mit Konkurrenzverhalten ist ein Verhalten gemeint, bei dem sich die Individuen versuchen gegenseitig zu überholen. 
%
%Solch ein Verhalten könnte in Paniksituationen entstehen, wenn ein Fressfeind in der Nähe ist. Konkurenzverhalten könnte auch entstehen, wenn Futter in der Nähe ist. Dann konkurrieren die Individuen untereinander und versuchen sich gegenseitig zu überholen, weil jeder als erster bei der Nahrung sein will. In solchen Situationen könnten unruhige und schnelle Bewegungen im Schwarm entstehen, sowie schnelle Formationsänderungen.
%
%Ein Konkurenzverhalten kann ausgelöst werden, indem das Gewicht für die Grundverhaltensregel, \textit{Ausrichtung}, auf einen Wert über 1 gesetzt wird. Voraussetzung ist hierbei allerdings, dass das Ausrichtungs-Gesetz so implementiert wurde, dass ein Boid nicht nur die Bewegungsrichtung, sondern auch die Bewegungsgeschwindigkeit seiner Nachbarschaft berücksichtigt. Wenn das Ausrichtungs-Gewicht größer als eins ist, wird der dadurch generierte Steuervektor größer sein als der Bewegungsvektor der Nachbarn.
%
%Das Konkurrenzverhalten sollte allerdings nur in Kombination einer Maximalgeschwindigkeit verwendet werden. Ansonsten könnte sich das System aufschaukeln, weil jedes Individuum versucht schneller als die Nachbarschaft zu sein.
%
%Der Schwarm könnte einen noch lebendigeren Eindruck hinterlassen, wenn das Gesetz \textit{Punkt meiden} mit einer Steigerung des Konkurrenzverhaltens begleitet werden würde. Sobald ein Jäger erscheint, würde der Schwarm nicht nur der Position des Jägers ausweichen. Der Schwarm würde dann auch seine Bewegungsmuster signifikant ändern. Im Idealfall wirken die neuen Bewegungsmuster des Schwarms  dann \glqq unruhig\grqq{}.
%
% 
%
%\section{Nachbearbeitung der Steuervektoren-Textur, $\vec{V}$}
%\label{subsec_leereZellen}
%
%Wie bereits erwähnt, können die beiden Texturen $\vec{V}$ und $D$ als ein Zellengittersystem verstanden werden, wobei jede Zelle ein eigenständiger Thread ist.
%Steht eine Berechnung an, führen alle Zellen gleichzeitig dieselbe Operation aus und speichern das Ergebnis, indem sie ihre eigenen Zustände, $D$ oder $\vec{V}$, ändern. Dabei wird ausnahmslos jede Zelle die gewünschte Arbeit erledigen, einzelne Zellen können sich nicht \glqq schlafen legen\grqq{}. 
%
%Das bedeutet, dass immer alle Zellen Steuersignale generieren. Sowohl leere, als auch volle Zellen. Mit leeren Zellen sind Zellen gemeint, die keine Boids besitzen, also für die $D=0$ gilt. Es ist durchaus möglich, dass leere Zellen Steuervektoren generieren.
%
%Wenn eine leere Zelle ein Steuersignal berechnet, ist dies nicht nur ein unnötiger Rechenaufwand. Ein solches Zellensystem kann zudem fehlinterpretiert werden, was schnell zu fehlerbehafteten Folgerechnungen führt. Hierzu ein Beispiel:
%Wenn ein Individuum in Abhängigkeit von den Bewegungsrichtungen seiner benachbarten Boids handeln möchte, wird es auf die Steuervektoren seiner benachbarten Zellen zugreifen. Im schlimmstem Fall kontrolliert das Individuum dabei aber nicht, ob ein ausgelesenes Steuersignal überhaupt einen Besitzer hat. Es würde dann die Bewegungsrichtung eines Boids berücksichtigen, das gar nicht existiert. 
%
%Diese  \glqq Strickfalle\grqq{} sollte daher frühzeitig abgefangen werden. Zum Beispiel indem nach der Erstellung der $\vec{V}$-Textur, die Steuersignale aller leeren Zellen auf $(0,0,0)$ gesetzt werden. Die Unreal Engine 4 bietet hierfür den Material-Knoten \textit{if} \cite{UE4MatIfNodes}. Hiermit kann $D$ mit Null verglichen und entsprechend gehandelt werden.
%
%
%
%\section{Transport der Boids}
%\label{section_BewDerBoids}
%
%
%
%In diesem Kapitel wird eine Lösungsmethode vorgestellt, wie die in $D$ enthaltenen Boids, mithilfe von $\vec{V}$, bewegt werden können. Diese Aufgabenstellung bringt eine Problematik mit sich, die dem Leser zunächst näher gebracht wird.
%
%\subsection{Problemstellung: Advektion mit Shadern}
%
%Die Bewegung oder Verzerrung von Texturen mithilfe von Vektorfeld-Texturen ist in der Videospieleprogrammierung keine Seltenheit. Diese Problemstellung tritt häufig bei der Erstellung von fließenden Gewässern, wie Bächen oder Flüssen, auf. Hierfür wird meist eine sogenannte \textit{Flow Map}-Textur hinterlegt. Eine Flow Map ist ein Vektorfeld das die Strömungsrichtungen einer Wasserfläche angibt. Die Verzerrung einer Flüssigkeits-Textur, mithilfe einer Flow Map, wird auch als Advektion bezeichnet. Hierbei werden Flüssigkeits-Partikel betrachtet, die von Vektoren durch den Raum transportiert werden. Betrachtet man jedes Boid wie ein Partikel, so wäre die Advektion eines Boids, das sich zum Zeitpunkt $t$ an der Position $x$ befindet, nicht besonders aufwändig.
%
%
%\bild{ProblAdvektion}{5cm}{Die herkömmliche Methode ein Objekt, das sich bei $x(t)$ befindet, mithilfe eines Bewegungsvektors, $V(x)$, zur neuen Position, $x(t+dt)$, zu bewegen.}
%
%Die Position, $x$, des in Abbildung \ref{ProblAdvektion} betrachteten Boids müsste dann einfach in Richtung des Vektors, $\vec{V}(x)$, versetzt werden. So wie in Formel \ref{Form_AdvektSimple} \cite{GPUGems1} gezeigt.
%
%\begin{equation}
%x(t + dt) = x(t) + \vec{V}(x,t) \cdot dt
%\label{Form_AdvektSimple}
%\end{equation}
%
%Das in Abbildung \ref{ProblAdvektion} betrachtete Pixel müsste laut Formel \ref{Form_AdvektSimple} seinen eigenen Wert in das Pixel schreiben, dessen Platz es einnehmen möchte. Diese Operation ist aber von Shadern nicht ausführbar (Siehe Kapitel \ref{subsec_ScatterVSGather}). 
%
%In \cite{GPUGems1} wird für diese Problemstellung eine Lösung vorgeschlagen. Hier wird eine implizite Methode \cite{Stam:1999} eingesetzt. Prinzipiell wird hier  $\vec{V}(x,t)$ genutzt, um in dessen entgegengesetzten Richtung nach der Herkunft des Pixels zu suchen, das nun die Position des betrachteten Pixels einnimmt. Dabei wird die Textur aus dem vorigem Zeitschritt durchsucht.
%
%Dieser Lösungsansatz ist allerdings nur für die Advektion einer inkompressiblen Flüssigkeit geeignet und nicht für das gegebene Boid-System.  
%
%Fluide werden meist als inkompressibel angesehen. Zwischen den Zellen eines Zellensystem, das ein Fluid repräsentiert, findet deswegen immer ein Druckausgleich statt. Dadurch kann beim Flüssigkeitssystem niemals der Fall auftreten, dass mehrere Flüssigkeitspartikel in dieselbe Zelle wandern, weil genau dann eine inhomogene Verteilung der Dichte und somit Kompression vorhanden wäre. Das heißt, dass alle Zellen eines Zellen-System, das ein Fluid beschreibt, stets gleich viele Wasserpartikel enthalten. Nur wenn diese Bedingung erfüllt ist, funktioniert die Advektions-Methode aus \cite{GPUGems1}.
%
%Beim Boid-System ist dies nicht erfüllt. Hier können mehrere Boids in dieselbe Zelle fließen und es gibt sowohl leere als auch volle Zellen. Wenn der Lösungsansatz aus \cite{GPUGems1} auf das Boid-System angewendet wird, besteht die Gefahr, dass leere Zellen verschoben werden und dabei volle Zellen überschreiben. So könnten dann Boids verloren gehen.
%
%Im Rahmen dieser Arbeit konnten keine passenden Methoden für die Advektion des Boid-Systems gefunden werden. Daher wird in den nächsten Kapiteln eine individuelle Methode entwickelt, die für die Bewegung des gegebenen Boid-Systems geeignet ist. Hierfür wird eine Gather-Methode entwickelt.
%
%
%
%\subsection{Definitionen und Vorschriften}
%\label{subsec_DefUVorschr}
%
%In diesem Kapitel wird festgelegt, wie sich eine Menge von Boids, $D(x)$, in Abhängigkeit eines gegebenen Steuervektors, $\vec{V}(x)$, bewegt und im Raum verteilt. Hierfür werden einige Definitionen festgelegt und Gesetze, die eingehalten werden müssen, vorgeschrieben.
%
%\subsubsection{Fließende Boids}
%
%Die Bewegung der Boids wird in dieser Arbeit auch als \textit{Boid-Fluss} bezeichnet.
%Dieser Begriff beinhaltet den Gedanken, dass sich eine Menge Boids nicht sprunghaft bewegt, sondern vielmehr  \glqq fließt\grqq{}. Eine Menge Boids soll nicht in einem Moment von einer Zelle in eine andere \glqq springen\grqq{}. Stattdessen sollen die Boids im übertragendem Sinne fließen und sich dabei gleichmäßig verteilen. Dadurch sollen natürlichere und flüssigere Bewegungen zustande kommen. 
%
%Würde immer der komplette Inhalt einer Zelle wandern, dann wäre auch immer dieselbe Menge Boids unterwegs. Nur beim Prinzip des Boid-Flusses kann sich der Inhalt einer Zelle auf mehrere Zellen verteilen, womit zu große Gruppenbildungen innerhalb einer Zelle vermieden werden können. Der Boid-Fluss soll sich auch vermischen können.
%
%\subsubsection{Die Anzahl der Boids ist konstant}
%
%Beim Transport der Boids sollte stets auf die Einhaltung des folgenden Gesetzes geachtet werden:
%
%\begin{equation}
%\sum_{i=1}^R \sum_{j=1}^R D(i,j)  = konstant
%\label{Form_BoidFlussKonst}
%\end{equation}
%
%Formel \ref{Form_BoidFlussKonst} legt fest, dass die Anzahl aller vorhandenen Boids konstant bleiben muss. Die Anzahl soll im Verlaufe der Simulation weder sinken noch fallen. Beim Boid-Transport muss darauf stets geachtet werden.
%
%
%\subsubsection{Ein Steuervektor entleert und befüllt dieselbe Menge Boids}
%\label{subsubsec_D_V}
%
%Gegeben sei eine Zelle $X$ bei $x$. Sie besitzt einen Steuervektor $\vec{V}$ und $D$ Boids.
%
%Der Steuervektor, $\vec{V}$, verursacht den Transport einer Menge Boids, $D_V$, wobei \\ $D_V <= D$ (damit Gesetz \ref{Form_BoidFlussKonst} eingehalten wird).
%
%Durch den Transport verliert Zelle $X$ $D_V$ Boids, während genau dieselbe Menge in ihrer Umgebung verteilt wird. Die Menge $D_V$ wird auf $N$ andere Zellen verteilt, diese Zellen werden als \textit{besuchte} Zellen bezeichnet. Jede besuchte Zelle bekommt eine Teilmenge von $D_V$, namens $D_{Vi}$ gutgeschrieben.
%
%\bild{LeafEqEnter}{14cm}{Es werden drei unterschiedliche Verteilungsarten gezeigt. Die rot markierte Zelle verteilt Boids in Richtung von $V$. Die Verteilende Zelle verliert dabei $D_V$ Boids. Genau diese Menge wird dann in die orange markierten Zellen verteilt. Hierfür können unterschiedliche Verteilungsarten konzipiert werden.}
%
%Die Summe aller $N$ Teilmengen, $D_{Vi}$, muss genau so groß sein, wie die verloren gegangene Menge $D_V$.
%
%\begin{equation}
%\sum_{i=1}^N(D_{V_i}) = D_V
%\label{Form_SummeD_V_i}
%\end{equation}
%
%Für die Verteilung von $D_V$ können, so wie in Abbildung \ref{LeafEqEnter} vorgeschlagen, unterschiedliche Verteilungsmethoden eingesetzt werden. $D_{Vi}$ kann einer einzigen Zelle überreicht oder auf mehrere Zellen verteilt werden.
%
%Bei der Verteilung muss aber immer Gleichung \ref{Form_SummeD_V_i} erfüllt sein. Außerdem sollten die Teilmengen, $D_{Vi}$, sinngemäß in Richtung des Steuervektors, $\vec{V}$, verteilt werden, damit sich die Boids in die angestrebte Richtung bewegen.
%
%
%
%
%\subsubsection{Maximale Bewegungsreichweite eines Boids}
%
%Bei der Advektion von Texturen sollte ein Pixel pro Zeitschritt nicht weiter als eine Pixellänge bewegt werden. Ansonsten können Instabilitäten entstehen, wodurch sich die bewegte Textur, laut \cite{GPUGems1}, explosionsartig aufblähen kann.
%
%Daher sollte bei der Simulation darauf geachtet werden, dass ein Boid pro Simulationsschritt keine Zelle überspringt. Diese Regel sollte bei der Konzipierung von Verteilungsmethoden berücksichtigt werden. Verteilungsmethoden wie die Methode, die in Abbildung \ref{LeafEqEnter} ganz rechts zu sehen ist, sollten daher vermieden werden.
%
%
%
%\subsection{Die Aktualisierungsformel für den Boid-Transport}
%Nachdem in Kapitel \ref{subsec_DefUVorschr} festgelegt wurde, nach welchen Gesetzen und Formeln sich der Schwarm im Zellensystem verteilen soll, kann eine allgemein gültige Formel für den Transport von $D$ aufgestellt werden.
%
%Grundsätzlich geben Zellen pro Simulationsschritt Boids an Nachbarzellen ab und nehmen neue Boids von ihren Nachbarn auf. Dieser Prozess kann über Formel \ref{Form_AdvektUeberischt} ausgedrückt werden:
%
%\begin{equation}
%D(x,t+dt) = D(x,t)-D_{leave}(x,t) + D_{enter}(x,t)
%\label{Form_AdvektUeberischt}
%\end{equation}
%
%In Gleichung \ref{Form_AdvektUeberischt} aktualisiert eine Zelle, die sich bei $x$ befindet, ihre Boids. Hierfür wird $D_{leave}(x,t)$ von $D(x,t)$ abgezogen und $D_{enter}(x,t)$ zu $D(x,t)$ addiert.
%
%In den nächsten beiden Kapiteln wird es darum gehen, den bis jetzt unbekannten Termen  $D_{leave}$ und $D_{enter}$ näher zu kommen.
%
%
%
%\subsection{Verlassene Zellen}
%\label{subsec_VerlasseneZellen}
%Gegeben sei eine Zelle $X$ am Ort $x$. Sie besitzt $D(x)$ Boids. Außerdem besitzt sie einen Steuervektor, $\vec{V}(x)$, für ihre Boids. $\vec{V}(x)$ repräsentiert den derzeitigen  \glqq Bewegungswunsch\grqq{} der in $X$ enthaltenen Boids. Im Steuervektor ist auch die Information enthalten, wieviele Boids aus der Zelle fließen werden, $D_{leave}(x)$. Die Länge des Steuervektors stellt dabei die Dringlichkeit des Bewegungswunsches dar. Ist $\vec{V}(x)$ groß, haben es die Boids im übertragendem Sinne \glqq eilig\grqq{}. Vielleicht weil gerade die Gefahr besteht den Anschluss zum Schwarm zu verlieren, weil ein Jäger in der Nähe ist, oder weil eine Kollisionsgefahr mit benachbarten Boids besteht. Deswegen sollte die Menge der Boids, die die Zelle verlassen, $D_{leave}(x)$, mit $\length{V(x)}$ wachsen.
%
%\begin{equation}
%D_{leave}(x) \thicksim \length{V(x)}
%\label{Form_DLeavePropV}
%\end{equation}
%
%Außerdem ist $D_{leave}(x)$ neben $\length{V(x)}$ auch abhängig von $D(x)$. $D_{leave}(x)$ ist schließlich eine Teilmenge von $D(x)$, wobei $D_{leave}(x) <= D(x)$.
%
%Daraus ergibt sich schlussendlich die finale Formel für $D_{leave}(x)$:
%
%\begin{equation}
%D_{leave}(x) = \length{V(x)} \cdot D(x)
%\label{Form_DLeaveFinal}
%\end{equation}
%
%Außerdem muss dabei stets Gleichung \ref{Form_lengthVOne} erfüllt sein, damit $D_{leave}(x) <= D(x)$ gilt.
%
%\begin{equation}
%\length{V(x)} <= 1
%\label{Form_lengthVOne}
%\end{equation}
%
%Bei der Generierung der Steuersignale sollte also stets darauf geachtet werden, das ein Steuervektor niemals größer als 1 wird.
%
%An dieser Stelle sollte die folgende Erkenntnis nicht fehlen: Die transportierte Menge, $D_V$, ist genauso groß wie die verlorene Menge, $D_{leave}$.
%
%\begin{equation}
%D_{leave}(x) = D_V(x)
%\label{Form_DLeaveEqDV}
%\end{equation}
%
%
%\subsection{Zellenbesuch}
%\label{sec_Zellenbesuch}
%
%Wie $D_{Enter}$ berechnet wird, hängt davon ab, nach welchem Verteilungsgesetz die transportierte Menge, $D_V$, verteilt wird. Im Rahmen dieser Arbeit wurden zwei Verteilungsmethoden entwickelt.
%
%Bei beiden Methoden findet der Boid-Austausch immer zwischen direkt benachbarten Zellen statt. Pro Simulationsschritt kann ein Boid also keine Zelle überspringen, was zu stabilen Simulationsergebnissen führen soll.
%
%
%\subsubsection{Verteilung in eine Nachbarzelle}
%
%Ein besonders einfaches Verteilungsgesetz ist die Verteilung der Menge $D_V$ in eine Nachbarzelle. Diese Methode bringt dabei den Vorteil eines geringen Rechenaufwands mit sich.
%
%Solange $\length{V}$ kleiner als 1 ist, kommt auch bei dieser einfachen Methode ein Boid-Fluss zustande, weil dann nur ein Teil von $D$ in eine benachbarte Zelle fließen kann.
%
%Es folgt anhand eines Beispiels die Beschreibung des festgelegten Verteilungsgesetzes:
%
%Gegeben sei eine Zelle, $X$, die sich an der Position $x=(u_x \qquad v_x)$, in einem zweidimensionalem Zellensystem befindet. Ihr Steuervektor, $\vec{V}(x)$, zeigt ungefähr auf die obere, rechte Nachbarzelle von $X$. $\vec{V}(x)$ sei also ungefähr $(1 \qquad -1)$.
%
%\bild{VerteilungInEineNachbarzelle}{7cm}{Auch wenn $V$ nicht exakt auf die orange markierte Zelle zeigt, bekommt diese 100\% von $D_V$ gut geschrieben.}
%
%Die Zelle $X$ wird dann $D_{leave}(x) = D_V(x)$ (Siehe Formel \ref{Form_DLeaveFinal}) Zellen verlieren und an die Nachbarzelle, auf die $V(x)$ zeigt, abgeben. Der Zelle, die sich bei $x + (1 \qquad -1)$ aufhält, werden dann $D_V(x)$ Boids gutgeschrieben.
%
%Aufgrund der Funktionsweise von Shadern kann die Zelle $X$ aber keine Werte in eine Nachbarzelle schreiben. Sie kann daher $D_V(x)$ nicht an ihre Nachbarzelle übergeben. Stattdessen müsste die Nachbarzelle selbst  \glqq erkennen\grqq{}, dass der Steuervektor $\vec{V}(x)$ von Zelle $X$ auf sie selbst zeigt. Denn nur die Nachbarzelle selbst, kann $D_V(x)$ zu ihren Boid-Bestand hinzufügen.
%
%Eine Zelle, $X$, muss also all Ihre direkten Nachbarn durchsuchen, um in Erfahrung zu bringen, ob eine oder mehrere Nachbarzellen auf sie selbst zeigen. Die Nachbarsuche kann mithilfe von normierten Testvektoren erfolgen, so wie in Abbildung \ref{AdvektVergleichsvektoren} dargestellt.
%
%\bild{AdvektVergleichsvektoren}{10cm}{Die rot eingefärbte Zelle untersucht ihre Nachbarschaft mit $N_c$ Testvektoren, $T_i$. Die Testvektoren repräsentieren auch die möglichen Bewegungsrichtungen die ein Boid einschlagen kann. Wenn nur 4 Testvektoren verwendet werden, heißt das auch, dass sich die Boids in nur 4 unterschiedliche Richtungen bewegen können.}
%
%Jeder Testvektor heißt $\vec{T}_i$ und ist normiert. In Abbildung \ref{AdvektVergleichsvektoren} werden $N_c=8$ Testvektoren eingesetzt. Die Position einer durchsuchten Nachbarzelle ist $x+\vec{T}_i/R$. $R$ ist die Auflösung der verwendeten Texturen.
%
%Ob eine Nachbarzelle von Zelle $X$ auf Position $x$ zeigt, kann herausgefunden werden, indem mit Vergleichsvektoren, $\vec{c}_i$, gearbeitet wird.
%
%Eine Nachbarzelle, die sich bei $x+\vec{T}_i \dfrac{1}{R}$ befindet, 
%%liefert eine Boid-Dichte, $D_i=D(x+\vec{T}_i \dfrac{1}{R})$, einen Steuervektor, $\vec{V}_i=\vec{V}(x+\vec{T}_i  \dfrac{1}{R})$ und 
%bekommt einen Vergleichsvektor, $\vec{c}_i$ zugeordnet. Eine Nachbarzelle liefert eine Boid-Dichte namens $D_i=D(x+\vec{T}_i \dfrac{1}{R})$ und einen Steuervektor namens $\vec{V}_i=\vec{V}(x+\vec{T}_i  \dfrac{1}{R})$.
%
%\bild{AdvektVergleichEineZelle}{7cm}{Der Steuervektor, $\vec{V}_i$, des rechten Nachbars von $X$, muss in die selbe Richtung wie $\vec{c}_i$ zeigen, damit es zu Boid-Austausch kommt. Dabei ist eine maximale Toleranz von $\beta/2$ erlaubt. In diesem Fall zeigt $\vec{V}_i$ in eine andere Richtung, daher wird es nicht zum Boid-Austausch kommen.}
%
%$\vec{c}_i$ ist ein normierter Vektor, der genau von der Nachbarzelle auf Zelle $X$ zeigt. Für $\vec{c}_i$ gilt:
%
%\begin{equation}
%c_i = -T_i
%\label{Form_CiEqTi}
%\end{equation}
%
%In Abbildung \ref{AdvektVergleichEineZelle} vergleicht die Zelle $X$ den Steuervektor einer Nachbarzelle, $\vec{V}_i$, mit $\vec{c}_i$. Hierfür wird ein Vergleichswinkel namens $\beta$, verwendet.  $\beta$ setzt sich wie folgt zusammen:
%
%\begin{equation}
%\beta = \dfrac{2 \pi}{N_c} \qquad N_c = [4 \qquad 8]
%\label{Form_Beta}
%\end{equation}
%
%Wobei $N_c$ die Anzahl der durchsuchten Nachbarzellen ist.
%
%Nur wenn der Winkel zwischen $\vec{V}_i$ und $\vec{c}_i$ kleiner als $\beta/2$ ist, kommt es zum Boid-Austausch zwischen den beiden Zellen aus Abbildung \ref{AdvektVergleichEineZelle}. Der Winkel zwischen den beiden Vektoren heißt $\alpha$, wobei $0 < \alpha < \pi$. Weil $\vec{c}_i$ ein normierter Vektor ist, gilt:  
%
%\begin{equation}
%e(\vec{V}_i) \cdot \vec{c}_i = \cos{\alpha}
%\end{equation}
%
%Die Bedingung $\alpha < \beta/2$ ist immer dann erfüllt wenn:
%
%\begin{equation}
%e(\vec{V}_i) \cdot \vec{c}_i > \cos{(\beta/2)} 
%\label{Form_AdvektBetaVergleich}
%\end{equation}
%
%Immer wenn Gleichung \ref{Form_AdvektBetaVergleich} erfüllt ist, war der Vektorvergleich erfolgreich und es kommt zum Boid-Austausch zwischen den beiden Zellen.  
%
%Für die Boid-Aufnahme wird Zelle $X$ die Menge der vom Nachbar ausgesendeten Boids, $D_{Enter_i}$, berechnen, um genau diese Menge aufzunehmen. $D_{Enter_i}$ berechnet sich wie folgt:
%
%\begin{equation}
%D_{Enter_i} = D_{Leave}(x+\dfrac{\vec{T}_i}{R}) = D(x+\dfrac{\vec{T}_i}{R}) \cdot |\vec{V}(x+\dfrac{\vec{T}_i}{R})| 
%\label{Form_D_V_Nachbar}
%\end{equation}
%
%Nachdem Zelle $X$ all ihre $N_c$ Nachbarn untersucht hat, sind $n_c$ Nachbarzellen bekannt, die ihre Boids an $X$ abgeben. Es gilt $0<=n_c<=N_c$. Aus jedem, der $n_c$ Nachbarn, entsteht ein $D_{Enter_i}$. Zelle $X$ nimmt dann insgesamt $D_{Enter}(x)$ Boids auf:
%
%\begin{equation}
%D_{Enter}(x) = \sum_{i=1}^{n_c} ( D_{Enter_i})
%\label{Form_D_EnterFinal}
%\end{equation}
%
%Um individuellere Bewegungen zu erhalten, lohnt es sich, alle 8 zur Verfügung stehenden Nachbarn durchzusuchen. Dann ist $N_c=8$. Das bedeutet, dass sich ein Boid pro Zeitschritt in eine von 8 unterschiedlichen Bewegungsrichtungen bewegen kann. Nämlich in die Richtungen, in die die 8 eingesetzten Testvektoren zeigen. 
%Es kann aber auch festgelegt werden, dass sich ein Boid nur in eine der 4 Richtungen $\vec{T}_1=(1 , 0)$, $\vec{T}_2=(-1,0)$, $\vec{T}_3=(0,1)$ oder $\vec{T}_4=(0,-1)$ bewegen kann. Dann wäre $N_c=4$ und der Vergleichswinkel $\beta/2$ größer.
%
%
%
%\subsubsection{Verteilung in zwei Zellen} %%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%Bei dieser Verteilungsmethode verteilt ein Steuervektor seine transportierte Menge, $D_V$, in zwei benachbarte Zellen. 
%
%Betrachtetet wird wieder eine Zelle, namens $X$, bei position $x$. Ihr eigener Steuervektor, $\vec{V}$, entzieht ihr wie immer eine Menge Boids, $D_V = D_{Leave}$. Die Menge, $D_V$, wird daraufhin in zwei Nachbarzellen, $X_1$ und $X_2$, verteilt. Dabei erhält Zelle $X_1$ $D_{V1}$ Boids und Zelle $X_2$ $D_{V2}$ Boids.
%
%Abbildung \ref{EnterSmoothIdea} visualisiert diese Art der Verteilung von $D_V$.
%
%\bild{EnterSmoothIdea}{4cm}{Bei der Verteilungsmethode \textit{Verteilung in zwei Zellen }verteilt die rot markierte Zelle, $X$, ihre Menge, $D_V$, in zwei Nachbarzellen (orange). }
%
%Bei der Verteilung der beiden Teilmengen  muss Gesetz \ref{Form_SummeD_V_i} erfüllt werden. Daher muss für die beiden Teilmengen gelten (siehe Formel \ref{FormTVTeilmengen}):
%
%\begin{equation}
%D_V = D_{V1} + D_{V2} 
%\label{FormTVTeilmengen}
%\end{equation}
%
%Formel \ref{FormTVTeilmengen} kann weiter aufgeschlüsselt werden in Gleichung \ref{FormTVTeilmengen2}:
%
%
%\begin{equation}
%D_V = m_1 \cdot D_V + m_2 \cdot D_V \qquad m_1 + m_2 = 1
%\label{FormTVTeilmengen2}
%\end{equation}
%
%Die beiden Faktoren $m_1$ und $m_2$ geben die Anteile an, die von $D_V$ entzogen und in Zelle $X_1$ und $X_2$ fließen sollen. Die summe aus $m_1$ und $m_2$ muss 1 sein, damit Gleichung \ref{FormTVTeilmengen} erfüllt wird.
%
%Bei der Aufteilung von $D_V$ zwischen den beiden Zellen $X_1$ und $X_2$ gilt folgende Regel: Die Zelle, auf die $\vec{V}$ eher zeigt, bekommt mehr von $D_V$ ab, als die andere Zelle. Zeigt $\vec{V}$ exakt auf $X_1$, bekommt $X_1$ $100\%$ von $D_V$ und $X_2$ bekommt nichts. Dann wäre $m_1=1$ und $m_2=0$. Zeigt $\vec{V}$ genau zwischen $X_1$ und $X_2$, bekommen beide Zellen gleichviel von $D_V$. Dann wäre $m_1=m_2=0,5$.
%
%Auch hier muss wieder eine Zelle $N_c$ Nachbarzellen untersuchen, um selbst herauszufinden, ob Nachbarzellen Boids abgeben wollen. Dabei kann, genau wie im vorigem Kapitel auch, mit normierten Testvektoren, $\vec{T}_i$, gearbeitet werden, die zu den Nachbarzellen zeigen. Der Steuervektor einer Nachbarzelle heißt wieder $\vec{V}_i$. $\vec{V}_i$ wird wieder mit einem Vergleichsvektor, $\vec{c}_i = -\vec{T}_i$ verglichen. Beim Vergleich wird der Winkel, $\alpha$, zwischen $\vec{V}_i$ und $\vec{c}_i$ betrachtet (siehe Abbildung \ref{VertIn2ZellenAlpha}).
%
%\bild{VertIn2ZellenAlpha}{7cm}{Zelle $X$ wird, je nachdem wie klein $\alpha$ ist, einen prozentualen Anteil von $D_{Vi}$ abbekommen. Der restlichen Teil wird in eine andere Zelle verteilt werden. In diesem Fall wird die Zelle, die sich unten rechts von $X$ befindet, einen größeren Anteil von $D_{Vi}$ bekommen als $X$.}
%
%Der Winkel $\alpha$ wird mit einem Winkel, $\beta = \dfrac{2 \pi}{N_c}$, verglichen. In Abbildung \ref{VertIn2ZellenAlpha} ist $\beta = \pi/2$, weil hier  $N_c=4$ gilt. Wenn $\alpha = 0$ ist, zeigt der Steuervektor des Nachbars genau auf Zelle $X$ und die Nachbarzelle wird $100\%$ von ihrer Menge, $D_V$, an $X$ abgeben. Wenn $\alpha \geq \beta$ ist, fließen keine Boids vom Nachbar zu $X$. Wenn $\alpha$ zwischen 0 und $\beta$ liegt, zeigt der Steuervektor der Nachbarzelle ungefähr in Richtung von $X$ und es wird der Anteil, $m_i \cdot D_{Vi}$ aus der Nachbarzelle zu $X$ fließen. $m_i$, soll eine lineare Funktion von $\alpha$ sein. Der Funktionsverlauf soll wie in Abbildung \ref{VertIn2ZellenFunktionModellierung} gezeigt, verlaufen: 
%
%\bild{VertIn2ZellenFunktionModellierung}{9cm}{$m_i$ als Funktion von $\alpha$. Sie muss linear sein, damit $D_{Vi}$ richtig aufgeteilt wird. Bekommt eine Zelle beispielsweise $70\%$, wird eine andere Zelle $30\%$ von $D_{Vi}$ ernten.}
%
%Mithilfe von Abbildung \ref{VertIn2ZellenFunktionModellierung} kann die gesuchte Funktion, $m_i$ von $\alpha$, aufgestellt werden:
%
%\begin{equation}
%m_i = - \dfrac{1}{\beta} \cdot \alpha + 1 \qquad m_i(\alpha \geq \beta)=0
%\label{Form_mi}
%\end{equation}
%
%Formel \ref{Form_mi} ist von $\alpha$ abhängig. $\alpha$ ist der Winkel zwischen $\vec{c}_i$ und $\vec{V}_i$ und kann mit dem Skalarprodukt ermittelt werden. So wie Formel \ref{Form_alpha2Zellen} zeigt:
%
%\begin{equation}
%\alpha = \arccos{( \vec{c}_i \cdot e(\vec{V}_i) )}
%\label{Form_alpha2Zellen}
%\end{equation}
%
%Zelle $X$ berechnet für jeden der $N_c$ Nachbarn ein $m_i$ und nimmt dann von jeder Nachbarzelle $m_i \cdot D_{Vi}$ Boids auf. $D_{Vi}$ ist die Menge Boids, die ein Nachbar verliert. Somit kann die finale Formel für die Verteilung in zwei Zellen gebildet werden (siehe Gleichung \ref{Form_Vert2ZellenFinal}):
%
%\begin{equation}
%D_{Enter}(x)=\sum_{i=1}^{N_c}(m_i \cdot D(x+\vec{T}_i \cdot \dfrac{1}{R}) \cdot |\vec{V}(x+\vec{T_i} \cdot \dfrac{1}{R})|  )
%\label{Form_Vert2ZellenFinal}
%\end{equation}
%
%Voraussetzung für Formel \ref{Form_Vert2ZellenFinal} ist, das die Testvektoren, $\vec{T}_i$, gleichmäßig und rotationssymmetrisch um $X$ herum verteilt sind und immer in Richtung Zentrum einer Zelle zeigen. Hierfür wird die Verwendung des folgenden Testvektorsets empfohlen: 
%
%$\vec{T}_1=(1 , 0)$, $\vec{T}_2=(-1,0)$, $\vec{T}_3=(0,1)$ und $\vec{T}_4=(0,-1)$.
